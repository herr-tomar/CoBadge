package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;
import osplus.apl.core.api.AplComponent;
import osplus.pkptuna.hazelcast.config.FlowConfig;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.flows.FlowHandlerRegistry;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 Der {@code GenericHazelcastRouter} ist für das Routing eingehender Nachrichten von Hazelcast
 ReliableTopics in partitionierte IMaps zuständig, basierend auf vordefinierten Flusskonfigurationen.
 Diese Komponente stellt sicher, dass das Routing nur von einer aktiven Instanz pro Cluster durchgeführt wird –
 mittels eines einfachen Leader-Election-Mechanismus.
 <p><strong>Hauptfunktionen:</strong></p>
 <ul>
 <li><strong>Leader-Election:</strong> Nur eine Instanz im Cluster übernimmt das Routing, indem sie einen
 eindeutigen Schlüssel (z.B. {@code active-router}) in der verteilten {@code router-leader-map} beansprucht.</li>
 <li><strong>ReliableTopic-Listener:</strong> Abonniert die konfigurierten Hazelcast ReliableTopics
 ausschließlich dann, wenn diese Instanz als Leader bestimmt wurde.</li>
 <li><strong>Router-Claim-Map:</strong> Verwendet die {@code router-claim-map}, um sicherzustellen,
 dass jede Nachricht nur einmal geroutet wird (idempotentes Routing) – basierend auf der Korrelation-ID.</li>
 <li><strong>Round-Robin-Partitionierung:</strong> Eingehende Nachrichten werden gleichmäßig auf
 partitionierte IMaps (z.B. {@code request-map0}, {@code request-map1}, ...) verteilt – mit einer
 Round-Robin-Strategie pro Flow.</li>
 </ul>
 Diese Router-Komponente gewährleistet Konsistenz, Skalierbarkeit und Fehlertoleranz in verteilten Umgebungen,
 ohne auf komplexe CP-Mechanismen oder externe Koordinationsdienste angewiesen zu sein.
 */
@AplComponent
public class GenericHazelcastRouter {

    private static final Logger LOGGER = LoggerFactory.getLogger(GenericHazelcastRouter.class);

    private final HazelcastInstance hazelcastInstance;
    private final List<FlowConfig> flowConfigs;
    private final FlowHandlerRegistry handlerRegistry;
    private final String routerInstanceId;

    private final Map<String, AtomicInteger> roundRobinCounters = new ConcurrentHashMap<>();

    @Autowired
    public GenericHazelcastRouter(HazelcastInstance hazelcastInstance,
                                  List<FlowConfig> flowConfigs,
                                  FlowHandlerRegistry handlerRegistry) {
        this(hazelcastInstance, flowConfigs, handlerRegistry, UUID.randomUUID().toString());
    }

    public GenericHazelcastRouter(HazelcastInstance hazelcastInstance,
                                  List<FlowConfig> flowConfigs,
                                  FlowHandlerRegistry handlerRegistry,
                                  String routerInstanceId) {
        this.hazelcastInstance = hazelcastInstance;
        this.flowConfigs = flowConfigs;
        this.handlerRegistry = handlerRegistry;
        this.routerInstanceId = routerInstanceId;
    }


    /**
     * Initialisiert die Routing-Konfigurationen nach dem Start.
     * Führt eine einfache Leader Election durch: nur ein aktiver Router pro Cluster.
     */
    @PostConstruct
    public void initRouters() {
        // Leader election
        IMap<String, String> leaderMap = hazelcastInstance.getMap("router-leader-map");
        String existingLeader = leaderMap.putIfAbsent("active-router", routerInstanceId);

        if (existingLeader != null) {
            LOGGER.info("This node is passive. Active router is already running with ID={}", existingLeader);
            return;
        } 

        LOGGER.info("This node is elected as the active router (ID={}). Initializing listeners...", routerInstanceId);

        if (flowConfigs == null || flowConfigs.isEmpty()) {
            LOGGER.warn("No Hazelcast flow configurations found.");
            return;
        }

        for (FlowConfig config : flowConfigs) {
            String flowName = config.name();
            roundRobinCounters.putIfAbsent(flowName, new AtomicInteger(0));

            @SuppressWarnings("unchecked")
            FlowHandler<Object, Object> handler = (FlowHandler<Object, Object>) handlerRegistry.getHandler(flowName);

            if (handler == null) {
                LOGGER.warn("No FlowHandler registered for flow: {}", flowName);
                continue;
            }

            ITopic<byte[]> topic = hazelcastInstance.getReliableTopic(config.requestTopic());
            topic.addMessageListener(new RoutingListener(flowName, config, handler));
            LOGGER.info("Listening on topic={} for flow={}", config.requestTopic(), flowName);
        }
    }

    /**
     * Listener-Klasse, die Nachrichten verarbeitet und sie dem korrekten Map-Partition zuweist.
     * Implementiert eine einfache Round-Robin-Strategie und einmalige Routing-Sicherung per Lock.
     */
    private class RoutingListener<T> implements MessageListener<byte[]> {

        private final String flowName;
        private final FlowConfig config;
        private final FlowHandler<T, ?> handler;

        RoutingListener(String flowName, FlowConfig config, FlowHandler<T, ?> handler) {
            this.flowName = flowName;
            this.config = config;
            this.handler = handler;
        }

        @Override
        public void onMessage(Message<byte[]> message) {
            try {
                IMap<String,String> leaderMap = hazelcastInstance.getMap("router-leader-map");
                String currentLeader = leaderMap.get("leader-" + flowName);

                if (!routerInstanceId.equals(currentLeader)) {
                    LOGGER.debug("Instance is not leader for flow '{}', skipping", flowName);
                    return;
                }

                T request = handler.deserializeRequest(message.getMessageObject());
                String correlationId = handler.extractCorrelationId(request);
                String lockKey = "route-lock-" + correlationId;

                IMap<String, String> routerMap = hazelcastInstance.getMap("router-claim-map");
                String uniqueId = UUID.randomUUID().toString();

                String existing = routerMap.putIfAbsent(lockKey, uniqueId);
                if (existing != null) {
                    LOGGER.info("Skipped duplicate routing for correlationId={}", correlationId);
                    return;
                }

                int index = roundRobinCounters.get(flowName).getAndIncrement() % config.partitions();
                String mapKey = config.mapBase() + index;

                hazelcastInstance.getMap(mapKey).put(correlationId, request);
                LOGGER.info("Routed correlationId='{}' to map '{}'", correlationId, mapKey);

            } catch (Exception e) {
                LOGGER.error("Routing failure for flow '{}': {}", flowName, e.getMessage(), e);
            }
        }
    }
}
