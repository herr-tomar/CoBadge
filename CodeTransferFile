// src/main/java/osplus/pkptuna/dispute/service/validation/Violation.java
package osplus.pkptuna.dispute.service.validation;

public record Violation(String field, String message) {}


------------

// src/main/java/osplus/pkptuna/dispute/service/validation/FunctionalValidationException.java
package osplus.pkptuna.dispute.service.validation;

import java.util.List;

public class FunctionalValidationException extends RuntimeException {
    private final List<Violation> violations;

    public FunctionalValidationException(List<Violation> violations) {
        super("Functional validation failed");
        this.violations = List.copyOf(violations);
    }

    public List<Violation> getViolations() {
        return violations;
    }
}


-----------

// src/main/java/osplus/pkptuna/dispute/service/validation/DisputeCreateValidator.java
package osplus.pkptuna.dispute.service.validation;

import osplus.pkptuna.rest.dispute.create.model.DisputeCreateRequestDto;

import java.util.ArrayList;
import java.util.List;

public final class DisputeCreateValidator {

    private DisputeCreateValidator() {}

    public static List<Violation> validate(DisputeCreateRequestDto s) {
        List<Violation> v = new ArrayList<>();

        // Pflichtfelder
        req(v, s.getImpulsOid(), "impulsOid");
        req(v, s.getReklaGrundKat1(), "reklaGrundKat1");

        // Teil/Voll-Logik
        boolean isPartial = isJ(s.getReklaTeilbetragKz());
        if (isPartial) {
            // refundRedebitAmount benötigt Betrag + Währung
            req(v, s.getReklaBetrag(), "reklaBetrag");
            req(v, s.getReklaBetragWs(), "reklaBetragWs");
            numeric(v, s.getReklaBetrag(), "reklaBetrag");
        }

        // Posting-Quelle (Originalbetrag/-währung) – paarig
        pairIfPresentMustBeBoth(v, s.getCrdVfggOrigBtrg(), s.getCrdVfggOrigWs(),
                "crdVfggOrigBtrg", "crdVfggOrigWs");
        if (notBlank(s.getCrdVfggOrigBtrg())) numeric(v, s.getCrdVfggOrigBtrg(), "crdVfggOrigBtrg");

        return v;
    }

    private static void req(List<Violation> v, String val, String field) {
        if (val == null || val.trim().isEmpty()) v.add(new Violation(field, "Pflichtfeld fehlt"));
    }

    private static void numeric(List<Violation> v, String val, String field) {
        if (val == null) return;
        try { Long.parseLong(val.trim()); }
        catch (Exception e) { v.add(new Violation(field, "Muss numerisch (Ganzzahl in Minor Units) sein")); }
    }

    private static void pairIfPresentMustBeBoth(List<Violation> v, String a, String b, String fa, String fb) {
        boolean ha = notBlank(a), hb = notBlank(b);
        if (ha ^ hb) v.add(new Violation(ha ? fb : fa, "Betrag/Währung müssen paarig vorkommen"));
    }

    private static boolean notBlank(String s) { return s != null && !s.trim().isEmpty(); }
    private static boolean isJ(String v) { return v != null && v.trim().equalsIgnoreCase("J"); }
}


---------


// src/main/java/osplus/pkptuna/dispute/service/normalization/DisputeCreateNormalizer.java
package osplus.pkptuna.dispute.service.normalization;

import osplus.pkptuna.rest.dispute.create.model.DisputeCreateRequestDto;

public final class DisputeCreateNormalizer {
    private DisputeCreateNormalizer() {}

    public static DisputeCreateRequestDto normalize(DisputeCreateRequestDto s) {
        // Minimale Normalisierung; Währung & Reason bleiben "as-is".
        if (s.getReklaBetrag() != null) s.setReklaBetrag(s.getReklaBetrag().trim());
        if (s.getCrdVfggOrigBtrg() != null) s.setCrdVfggOrigBtrg(s.getCrdVfggOrigBtrg().trim());
        if (s.getImpulsOid() != null) s.setImpulsOid(s.getImpulsOid().trim());
        if (s.getReklaGrundKat1() != null) s.setReklaGrundKat1(s.getReklaGrundKat1().trim());
        return s;
    }
}


----------------

