package osplus.pkp.dto.plugin;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import freemarker.template.Version;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;
import osplus.pkp.dto.model.ProtoFieldModel;
import osplus.pkp.dto.model.ProtoMessageModel;
import osplus.pkp.dto.util.ProtoParserUtil;
import osplus.pkp.dto.util.TemplateWriterUtil;

import java.io.File;
import java.io.IOException;
import java.util.*;

/**
 * Generator-Klasse für REST-DTOs und MapStruct-Mapping-Interfaces
 * basierend auf .proto-Dateien.
 *
 * Diese Klasse analysiert alle .proto-Dateien im angegebenen Eingabeverzeichnis,
 * generiert REST-DTOs und entsprechende Mapper mit Hilfe von FreeMarker-Templates.
 */
public final class RestDtoGeneratorPlugin {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestDtoGeneratorPlugin.class);

    private static final String REST_PACKAGE_NAME = "rest";
    private static final String TEMPLATE_DIRECTORY = "/templates";
    private static final String DTO_TEMPLATE_FILE = "rest-dto.ftl";
    private static final String MAPPER_TEMPLATE_FILE = "rest-mapper.ftl";
    private static final String MAPPER_SUBPACKAGE = ".mapper";
    private static final String JAVA_FILE_EXTENSION = ".java";
    private static final String UTF_8 = "UTF-8";
    private static final String PACKAGE_SEPARATOR = "\\.";
    private static final String DOT = ".";

    private static final String REQUEST_CHANNEL = "APL-UI";
    private static final String MESSAGE_TYPE_LOOKUP = "DISPUTE_LOOKUP";
    private static final String MESSAGE_TYPE_DETAIL = "DISPUTE_FOLDER_DETAIL";

    private RestDtoGeneratorPlugin() {
        // Verhindert Instanziierung
    }

    /**
     * Startpunkt des Generators.
     *
     * @param args Erwartet zwei Argumente: Eingabeverzeichnis (proto) und Ausgabeverzeichnis (DTO)
     */
    public static void main(String[] args) {
        if (args.length < 2) {
            LOGGER.error("Verwendung: RestDtoGeneratorPlugin <protoInputDir> <restDtoOutputDir>");
            System.exit(1);
        }

        File protoDir = new File(args[0]);
        File outputDir = new File(args[1]);

        if (!protoDir.exists() || !protoDir.isDirectory()) {
            LOGGER.error("Ungültiges Eingabeverzeichnis: {}", protoDir.getAbsolutePath());
            System.exit(2);
        }

        outputDir.mkdirs();

        try {
            Configuration cfg = configureFreemarker();

            Template dtoTemplate = cfg.getTemplate(DTO_TEMPLATE_FILE);
            Template mapperTemplate = cfg.getTemplate(MAPPER_TEMPLATE_FILE);

            List<ProtoMessageModel> messageModels = ProtoParserUtil.parseAll(protoDir);

            for (ProtoMessageModel model : messageModels) {
                generateDtoAndMapper(model, outputDir, dtoTemplate, mapperTemplate);
            }

            LOGGER.info("Generierung von REST-DTOs und Mapper-Interfaces erfolgreich abgeschlossen.");
        } catch (IOException e) {
            LOGGER.error("Fehler beim Laden der Templates: {}", e.getMessage(), e);
            System.exit(3);
        } catch (Exception e) {
            LOGGER.error("Unerwarteter Fehler beim Generieren: {}", e.getMessage(), e);
            System.exit(4);
        }
    }

    /**
     * Konfiguriert die Freemarker-Template-Engine.
     *
     * @return konfigurierte {@link Configuration}-Instanz
     * @throws IOException falls ein Problem beim Zugriff auf Templates besteht
     */
    private static Configuration configureFreemarker() throws IOException {
        Configuration cfg = new Configuration(new Version("2.3.32"));
        cfg.setClassForTemplateLoading(RestDtoGeneratorPlugin.class, TEMPLATE_DIRECTORY);
        cfg.setDefaultEncoding(UTF_8);
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        return cfg;
    }

    /**
     * Generiert DTO- und Mapper-Dateien für ein Proto-Modell.
     *
     * @param model           das Protobuf-Modell
     * @param outputDir       das Ausgabeverzeichnis
     * @param dtoTemplate     das DTO-Template
     * @param mapperTemplate  das Mapper-Template
     */
    private static void generateDtoAndMapper(ProtoMessageModel model,
                                             File outputDir,
                                             Template dtoTemplate,
                                             Template mapperTemplate) {

        String protoPackage = model.getPackageName();
        String restPackage = insertRestInPackage(protoPackage);
        String mapperPackage = restPackage + MAPPER_SUBPACKAGE;

        // DTO-Datei
        String dtoPath = restPackage.replace(DOT, "/");
        File dtoDir = new File(outputDir, dtoPath);
        dtoDir.mkdirs();

        Map<String, Object> dtoData = new HashMap<>();
        dtoData.put("packageName", restPackage);
        dtoData.put("className", model.getClassName());
        dtoData.put("fields", model.getFields());

        File dtoFile = new File(dtoDir, model.getClassName() + JAVA_FILE_EXTENSION);
        TemplateWriterUtil.writeTemplate(dtoTemplate, dtoData, dtoFile);

        // Mapper-Datei
        List<String> fullMapperClassNames = new ArrayList<>();
        List<String> simpleMapperClassNames = new ArrayList<>();

        for (ProtoFieldModel field : model.getFields()) {
            if (field.isCustomType()) {
                String full = restPackage + MAPPER_SUBPACKAGE + DOT + field.getProtoType() + "Mapper";
                fullMapperClassNames.add(full);
                simpleMapperClassNames.add(field.getProtoType() + "Mapper");
            }
        }

        List<Map<String, String>> repeatedFieldMappings = new ArrayList<>();
        for (ProtoFieldModel field : model.getFields()) {
            if (field.isRepeated()) {
                Map<String, String> map = new HashMap<>();
                map.put("source", field.getName() + "List");
                map.put("target", field.getName());
                repeatedFieldMappings.add(map);
            }
        }

        Map<String, Object> mapperData = new HashMap<>();
        mapperData.put("mapperPackage", mapperPackage);
        mapperData.put("protoDtoPackage", protoPackage);
        mapperData.put("protoDtoClassName", model.getClassName());
        mapperData.put("restDtoPackage", restPackage);
        mapperData.put("restDtoClassName", model.getClassName());
        mapperData.put("mapperInterfaceName", model.getClassName() + "Mapper");
        mapperData.put("customMapperImports", fullMapperClassNames);
        mapperData.put("customMapperSimpleNames", simpleMapperClassNames);
        mapperData.put("repeatedFieldMappings", repeatedFieldMappings);

        File mapperDir = new File(outputDir, mapperPackage.replace(DOT, "/"));
        mapperDir.mkdirs();

        File mapperFile = new File(mapperDir, model.getClassName() + "Mapper" + JAVA_FILE_EXTENSION);
        TemplateWriterUtil.writeTemplate(mapperTemplate, mapperData, mapperFile);
    }

    /**
     * Fügt im Package-Namen ein "rest" Segment nach dem zweiten Teil hinzu.
     *
     * @param originalPackage Ursprünglicher Package-Name
     * @return modifizierter Package-Name mit "rest"
     */
    private static String insertRestInPackage(String originalPackage) {
        String[] parts = originalPackage.split(PACKAGE_SEPARATOR);
        if (parts.length >= 2 && !REST_PACKAGE_NAME.equals(parts[2])) {
            List<String> modified = new ArrayList<>(Arrays.asList(parts));
            modified.add(2, REST_PACKAGE_NAME);
            return String.join(DOT, modified);
        }
        return originalPackage;
    }
}


-------------

package osplus.pkp.dto.plugin;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Testklasse für {@link RestDtoGeneratorPlugin}, die sowohl positive als auch negative
 * Testfälle für die Codegenerierung aus .proto-Dateien abdeckt.
 */
class RestDtoGeneratorPluginTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestDtoGeneratorPluginTest.class);

    private File testProtoDir;
    private File testOutputDir;

    /**
     * Erstellt temporäre Testverzeichnisse und Beispiel-Proto-Dateien vor jedem Test.
     */
    @BeforeEach
    void setUp() throws IOException {
        testProtoDir = Files.createTempDirectory("proto-test").toFile();
        testOutputDir = Files.createTempDirectory("output-test").toFile();

        String protoContent = """
            syntax = "proto3";
            package osplus.pkptuna.test;

            message SampleDto {
                string id = 1;
                repeated string tags = 2;
            }
        """;

        File protoFile = new File(testProtoDir, "sample.proto");
        Files.writeString(protoFile.toPath(), protoContent);
    }

    /**
     * Testet die erfolgreiche Generierung der DTO- und Mapper-Dateien aus einer .proto-Datei.
     */
    @Test
    void testGenerateRestDtoAndMapper() {
        String[] args = { testProtoDir.getAbsolutePath(), testOutputDir.getAbsolutePath() };
        RestDtoGeneratorPlugin.main(args);

        // Prüfe ob DTO-Datei erzeugt wurde
        File dtoFile = new File(testOutputDir, "osplus/pkptuna/rest/test/SampleDto.java");
        assertTrue(dtoFile.exists(), "DTO-Datei sollte existieren");

        // Prüfe DTO-Inhalt
        try {
            String dtoContent = Files.readString(dtoFile.toPath());
            assertTrue(dtoContent.contains("class SampleDto"), "DTO sollte Klassendeklaration enthalten");
            assertTrue(dtoContent.contains("private String id"), "DTO sollte Feld 'id' enthalten");
            assertTrue(dtoContent.contains("List<String> tags"), "DTO sollte 'tags' als Liste enthalten");
        } catch (IOException e) {
            fail("Fehler beim Lesen der generierten DTO-Datei: " + e.getMessage());
        }

        // Prüfe ob Mapper-Datei erzeugt wurde
        File mapperFile = new File(testOutputDir, "osplus/pkptuna/rest/test/mapper/SampleDtoMapper.java");
        assertTrue(mapperFile.exists(), "Mapper-Datei sollte existieren");

        try {
            String mapperContent = Files.readString(mapperFile.toPath());
            assertTrue(mapperContent.contains("interface SampleDtoMapper"), "Mapper sollte korrekte Schnittstelle deklarieren");
            assertTrue(mapperContent.contains("toRestDto"), "Mapper sollte Konvertierungsmethode enthalten");
        } catch (IOException e) {
            fail("Fehler beim Lesen der generierten Mapper-Datei: " + e.getMessage());
        }
    }

    /**
     * Testet das Verhalten bei ungültigem Verzeichnis.
     */
    @Test
    void testInvalidProtoDirectory() {
        String[] args = { "invalid_dir", testOutputDir.getAbsolutePath() };
        Exception exception = assertThrows(Exception.class, () -> RestDtoGeneratorPlugin.main(args));
        assertNotNull(exception.getMessage());
    }

    /**
     * Testet das Verhalten bei fehlenden Argumenten.
     */
    @Test
    void testMissingArguments() {
        String[] args = {};
        Exception exception = assertThrows(Exception.class, () -> RestDtoGeneratorPlugin.main(args));
        assertNotNull(exception.getMessage());
    }

    /**
     * Löscht temporäre Dateien nach den Tests.
     */
    @AfterEach
    void tearDown() {
        deleteRecursively(testProtoDir);
        deleteRecursively(testOutputDir);
    }

    /**
     * Hilfsmethode zum rekursiven Löschen eines Verzeichnisses.
     *
     * @param file Die Datei oder das Verzeichnis, das gelöscht werden soll.
     */
    private void deleteRecursively(File file) {
        if (file != null && file.exists()) {
            if (file.isDirectory()) {
                File[] children = file.listFiles();
                if (children != null) {
                    for (File child : children) {
                        deleteRecursively(child);
                    }
                }
            }
            if (!file.delete()) {
                LOGGER.warn("Konnte Datei nicht löschen: {}", file.getAbsolutePath());
            }
        }
    }
}
