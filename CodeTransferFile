package osplus.pkp.dto.plugin;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import freemarker.template.Version;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;
import osplus.pkp.dto.model.ProtoFieldModel;
import osplus.pkp.dto.model.ProtoMessageModel;
import osplus.pkp.dto.util.ProtoParserUtil;
import osplus.pkp.dto.util.TemplateWriterUtil;

import java.io.File;
import java.io.IOException;
import java.util.*;

/**
 * Generator-Plugin zur automatisierten Erstellung von REST-DTOs und MapStruct-Mapping-Interfaces
 * auf Basis von .proto-Dateien.
 */
public final class RestDtoGeneratorPlugin {

    private static final Logger LOGGER = LoggerFactory.getLogger(RestDtoGeneratorPlugin.class);

    private static final String TEMPLATE_DIRECTORY = "/templates";
    private static final String ENCODING_UTF_8 = "UTF-8";
    private static final String TEMPLATE_REST_DTO = "rest-dto.ftl";
    private static final String TEMPLATE_REST_MAPPER = "rest-mapper.ftl";
    private static final String KEY_PACKAGE_NAME = "packageName";
    private static final String KEY_CLASS_NAME = "className";
    private static final String KEY_FIELDS = "fields";
    private static final String KEY_MAPPER_PACKAGE = "mapperPackage";
    private static final String KEY_PROTO_DTO_PACKAGE = "protoDtoPackage";
    private static final String KEY_PROTO_DTO_CLASS_NAME = "protoDtoClassName";
    private static final String KEY_REST_DTO_PACKAGE = "restDtoPackage";
    private static final String KEY_REST_DTO_CLASS_NAME = "restDtoClassName";
    private static final String KEY_MAPPER_INTERFACE_NAME = "mapperInterfaceName";
    private static final String KEY_CUSTOM_IMPORTS = "customMapperImports";
    private static final String KEY_CUSTOM_SIMPLE_NAMES = "customMapperSimpleNames";
    private static final String KEY_REPEATED_MAPPINGS = "repeatedFieldMappings";

    private RestDtoGeneratorPlugin() {
        // Verhindert Instanziierung
    }

    /**
     * Einstiegspunkt für Kommandozeilen-Ausführung.
     *
     * @param args Argumente: [0] = Pfad zum Proto-Verzeichnis, [1] = Ausgabeverzeichnis
     */
    public static void main(String[] args) {
        try {
            generate(args);
        } catch (IllegalArgumentException e) {
            LOGGER.error(e.getMessage());
            System.exit(1);
        } catch (IOException e) {
            LOGGER.error("Fehler beim Verarbeiten der Dateien.", e);
            System.exit(2);
        } catch (Exception e) {
            LOGGER.error("Unerwarteter Fehler beim Generieren der DTOs.", e);
            System.exit(3);
        }
    }

    /**
     * Führt die DTO- und Mapper-Generierung anhand der übergebenen Argumente aus.
     *
     * @param args Argumente: [0] = Pfad zum Proto-Verzeichnis, [1] = Ausgabeverzeichnis
     * @throws IOException bei Datei- oder Templatefehlern
     */
    public static void generate(String[] args) throws IOException {
        if (args.length < 2) {
            throw new IllegalArgumentException("Usage: RestDtoGeneratorPlugin <protoInputDir> <restDtoOutputDir>");
        }

        File protoDir = new File(args[0]);
        File outputDir = new File(args[1]);

        if (!protoDir.exists() || !protoDir.isDirectory()) {
            throw new IllegalArgumentException("Ungültiges Proto-Verzeichnis: " + protoDir.getAbsolutePath());
        }

        outputDir.mkdirs();

        Configuration cfg = new Configuration(new Version("2.3.32"));
        cfg.setClassForTemplateLoading(RestDtoGeneratorPlugin.class, TEMPLATE_DIRECTORY);
        cfg.setDefaultEncoding(ENCODING_UTF_8);
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

        Template dtoTemplate = cfg.getTemplate(TEMPLATE_REST_DTO);
        Template mapperTemplate = cfg.getTemplate(TEMPLATE_REST_MAPPER);

        List<ProtoMessageModel> messageModels = ProtoParserUtil.parseAll(protoDir);

        for (ProtoMessageModel model : messageModels) {
            generateDto(dtoTemplate, outputDir, model);
            generateMapper(mapperTemplate, outputDir, model);
        }

        LOGGER.info("REST DTO- und Mapper-Generierung erfolgreich abgeschlossen.");
    }

    private static void generateDto(Template dtoTemplate, File outputDir, ProtoMessageModel model) throws IOException {
        String protoPackage = model.getProtoPackageName(); // safer and guaranteed set
        String restPackage = insertRestInPackage(protoPackage);

        String dtoPath = restPackage.replace('.', '/');
        File dtoDir = new File(outputDir, dtoPath);
        dtoDir.mkdirs();

        Map<String, Object> dtoData = new HashMap<>();
        dtoData.put(KEY_PACKAGE_NAME, restPackage);
        dtoData.put(KEY_CLASS_NAME, model.getClassName());
        dtoData.put(KEY_FIELDS, model.getFields());

        File dtoFile = new File(dtoDir, model.getClassName() + ".java");
        TemplateWriterUtil.writeTemplate(dtoTemplate, dtoData, dtoFile);
    }

    private static void generateMapper(Template mapperTemplate, File outputDir, ProtoMessageModel model) throws IOException {
        String protoPackage = model.getProtoPackageName(); // not getPackageName()
        String restPackage = insertRestInPackage(protoPackage);
        String mapperPackage = restPackage + ".mapper";

        Set<String> fullMapperClassSet = new HashSet<>();
        Set<String> simpleMapperClassSet = new HashSet<>();

        for (ProtoFieldModel field : model.getFields()) {
            if (field.isCustomType()) {
                fullMapperClassSet.add(restPackage + ".mapper." + field.getProtoType() + "Mapper");
                simpleMapperClassSet.add(field.getProtoType() + "Mapper");
            }
        }

        List<Map<String, String>> repeatedFieldMappings = new ArrayList<>();
        for (ProtoFieldModel field : model.getFields()) {
            if (field.isRepeated()) {
                Map<String, String> mapping = new HashMap<>();
                mapping.put("source", field.getName() + "List");
                mapping.put("target", field.getName());
                repeatedFieldMappings.add(mapping);
            }
        }

        Map<String, Object> mapperData = new HashMap<>();
        mapperData.put(KEY_MAPPER_PACKAGE, mapperPackage);
        mapperData.put(KEY_PROTO_DTO_PACKAGE, protoPackage);
        mapperData.put(KEY_PROTO_DTO_CLASS_NAME, model.getClassName());
        mapperData.put(KEY_REST_DTO_PACKAGE, restPackage);
        mapperData.put(KEY_REST_DTO_CLASS_NAME, model.getClassName());
        mapperData.put(KEY_MAPPER_INTERFACE_NAME, model.getClassName() + "Mapper");
        mapperData.put(KEY_CUSTOM_IMPORTS, new ArrayList<>(fullMapperClassSet));
        mapperData.put(KEY_CUSTOM_SIMPLE_NAMES, new ArrayList<>(simpleMapperClassSet));
        mapperData.put(KEY_REPEATED_MAPPINGS, repeatedFieldMappings);


        File mapperDir = new File(outputDir, mapperPackage.replace('.', '/'));
        mapperDir.mkdirs();

        File mapperFile = new File(mapperDir, model.getClassName() + "Mapper.java");
        TemplateWriterUtil.writeTemplate(mapperTemplate, mapperData, mapperFile);
    }

    /**
     * Fügt ".rest" als Bestandteil in den Package-Namen ein, sofern noch nicht enthalten.
     *
     * @param originalPackage Ursprünglicher Package-Name
     * @return Neuer Package-Name mit ".rest"
     */
    private static String insertRestInPackage(String originalPackage) {
        final String[] parts = originalPackage.split("\\.");

        if (parts.length < 2) {
            LOGGER.warn("Package name is smaller than 2 segments: '{}'. 'rest' will not be inserted.", originalPackage);
            return originalPackage;
        }

        if (parts.length >= 3 && "rest".equals(parts[2])) {
            return originalPackage;
        }

        final List<String> result = new ArrayList<>(Arrays.asList(parts));
        result.add(Math.min(2, result.size()), "rest");  // Insert safely
        return String.join(".", result);
    }
}
