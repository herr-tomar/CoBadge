package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import osplus.pkptuna.hazelcast.config.FlowConfig;
import osplus.pkptuna.hazelcast.config.FlowHandlerTestConfiguration;
import osplus.pkptuna.hazelcast.config.HazelcastConfigProps;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.flows.FlowHandlerRegistry;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.mockito.Mockito.*;

@SpringBootTest(classes = FlowHandlerTestConfiguration.class)
public class GenericHazelcastConsumerTest {

    @Autowired
    private HazelcastConfigProps hazelcastConfigProps;

    @Autowired
    private FlowHandlerRegistry handlerRegistry;

    @Autowired
    private FlowHandler sampleFlowHandler;

    @Autowired
    private HazelcastInstance hazelcastInstance;

    @Autowired
    private GenericHazelcastConsumer consumer;

    /**
     * Positiver Test: Überprüft, ob ein gültiger Flow korrekt verarbeitet wird.
     */
    @Test
    public void testPollRequestMaps_PositiveFlow() {
        FlowConfig config = new FlowConfig("sampleFlow", "map", 1, "responseTopic");

        Map<Object, Object> data = new HashMap<>();
        data.put("corrId1", "request1");

        IMap<Object, Object> mockMap = mock(IMap.class);
        when(hazelcastInstance.getMap("map0")).thenReturn(mockMap);
        when(mockMap.entrySet()).thenReturn(data.entrySet());

        // Optionally mock behavior on sampleFlowHandler if needed
        when(sampleFlowHandler.handleRequest("request1")).thenReturn("response1");
        when(sampleFlowHandler.wrapResponse("corrId1", "response1")).thenReturn("wrappedResponse");

        consumer = new GenericHazelcastConsumer(null, hazelcastInstance, null, List.of(config), handlerRegistry, hazelcastConfigProps);
        consumer.pollRequestMaps();

        verify(sampleFlowHandler).sendResponse(hazelcastInstance, "responseTopic", "wrappedResponse");
        verify(mockMap).remove("corrId1");
    }

    /**
     * Negativer Test: Kein Handler für den Flow vorhanden.
     */
    @Test
    public void testPollRequestMaps_NoHandlerFound() {
        FlowConfig config = new FlowConfig("unknownFlow", "map", 1, "none");

        Map<Object, Object> data = new HashMap<>();
        data.put("id1", "request");

        IMap<Object, Object> mockMap = mock(IMap.class);
        when(hazelcastInstance.getMap("map0")).thenReturn(mockMap);
        when(mockMap.entrySet()).thenReturn(data.entrySet());

        consumer = new GenericHazelcastConsumer(null, hazelcastInstance, null, List.of(config), handlerRegistry, hazelcastConfigProps);
        consumer.pollRequestMaps();

        // Since no handler exists, no remove or send should happen
        verify(mockMap, never()).remove(any());
    }

    /**
     * Negativer Test: Exception beim Verarbeiten der Anfrage.
     */
    @Test
    public void testPollRequestMaps_HandlerThrowsException() {
        FlowConfig config = new FlowConfig("sampleFlow", "map", 1, "responseTopic");

        Map<Object, Object> data = new HashMap<>();
        data.put("id123", "faultyRequest");

        IMap<Object, Object> mockMap = mock(IMap.class);
        when(hazelcastInstance.getMap("map0")).thenReturn(mockMap);
        when(mockMap.entrySet()).thenReturn(data.entrySet());

        when(sampleFlowHandler.handleRequest("faultyRequest")).thenThrow(new RuntimeException("Expected failure"));

        consumer = new GenericHazelcastConsumer(null, hazelcastInstance, null, List.of(config), handlerRegistry, hazelcastConfigProps);
        consumer.pollRequestMaps();

        verify(mockMap, never()).remove("id123");
    }
}
