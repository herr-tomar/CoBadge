package osplus.pkptuna.dispute.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.HttpHeaders;
import org.springframework.web.reactive.function.client.WebClient;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;
import osplus.pkptuna.dispute.config.DisputeServiceProperties;
import osplus.pkptuna.dispute.create.model.DisputeCreateRequestDto;
import osplus.pkptuna.dispute.create.model.DisputeCreateResponseDto;
import osplus.pkptuna.dispute.lookup.model.DisputeFolderEntryDto;
import osplus.pkptuna.dispute.lookup.model.DisputeLookupIboResponseDto;
import osplus.pkptuna.dispute.lookup.model.DisputeLookupResponseDto;
import osplus.pkptuna.dispute.service.DisputeService;
import osplus.pkptuna.dispute.service.mapping.DynsToIboCreateMapper;
import osplus.pkptuna.dispute.service.normalization.DisputeCreateNormalizer;
import osplus.pkptuna.dispute.service.validation.DisputeCreateValidator;
import osplus.pkptuna.dispute.service.validation.FunctionalValidationException;
import osplus.pkptuna.dispute.service.validation.Violation;
import osplus.pkptuna.protobuf.util.ProtobufJsonUtil;
import osplus.pkptuna.rest.dispute.create.model.mapper.DisputeCreateRequestDtoMapper;
import osplus.pkptuna.rest.dispute.ibo.create.model.DisputeIboCreateRequestDto;
import osplus.pkptuna.rest.dispute.ibo.create.model.DisputeIboCreateResponseDto;
import osplus.pkptuna.rest.dispute.ibo.transaction.identifier.model.DisputeIboTransactionRequestDto;
import osplus.pkptuna.rest.dispute.ibo.transaction.identifier.model.DisputeIboTransactionResponseDto;

import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Implementierung des {@link DisputeService}, die über einen konfigurierten {@link WebClient}
 * mit dem externen IBO-Service kommuniziert.
 * <p>
 * Diese Klasse bietet Funktionen zur:
 * <ul>
 *   <li>Abfrage bestehender Dispute-Ordner anhand von Issuer-ID und Kartenreferenz</li>
 *   <li>Erstellung neuer Dispute-Ordner im IBO-System inklusive Validierung und Normalisierung der Eingabedaten</li>
 * </ul>
 * <p>
 * Sie kapselt die komplette Ablaufsteuerung, inklusive:
 * <ol>
 *   <li>Mapping zwischen internen Protobuf-DTOs und den IBO-spezifischen REST-DTOs</li>
 *   <li>HTTP-Aufrufen an die jeweiligen Endpunkte des IBO-Services</li>
 *   <li>Prüfung der Antwortmetadaten auf Erfolg</li>
 *   <li>Extraktion der relevanten Rückgabewerte</li>
 * </ol>
 * </p>
 *
 * <strong>Thread-Sicherheit:</strong> Diese Implementierung ist threadsicher, sofern die übergebenen
 * abhängigen Komponenten (Mapper, {@code WebClient}, {@code ObjectMapper}) threadsicher sind.
 */
public class DisputeServiceImpl implements DisputeService {

    private static final Logger LOGGER = LoggerFactory.getLogger(DisputeServiceImpl.class);
    private final WebClient webClient;
    private final String username;
    private final String password;
    private final String pathDisputeLookup;
    private final String pathDisputeFolderCreate;
    private final String pathLookupTransactionId;
    private final DisputeCreateRequestDtoMapper disputeCreateRequestDtoMapper;
    private final ObjectMapper objectMapper;

    private DynsToIboCreateMapper dynsToIboCreateMapper;

    /**
     * Erstellt eine neue Instanz des {@code DisputeServiceImpl}.
     * <p>
     * Initialisiert den internen {@link WebClient} für REST-Aufrufe an den IBO-Service
     * und speichert alle für Authentifizierung und Endpunktpfade erforderlichen
     * Konfigurationseigenschaften.
     * </p>
     *
     * @param webClient                    der konfigurierte {@link WebClient} für HTTP-Aufrufe
     * @param props                        die Konfigurationseigenschaften für Authentifizierung und Pfade
     * @param disputeCreateRequestDtoMapper Mapper zum Umwandeln des eingehenden Protobuf-DTOs
     *                                       in das REST-DTO für den IBO-Service
     * @param dynsToIboCreateMapper         Mapper zum Umwandeln des normalisierten REST-DTOs
     *                                       in das IBO-spezifische Create-Request-DTO
     * @param objectMapper                  Jackson {@link ObjectMapper} für JSON-(De)Serialisierung
     */
    public DisputeServiceImpl(final WebClient webClient,
                              final DisputeServiceProperties props,
                              DisputeCreateRequestDtoMapper disputeCreateRequestDtoMapper,
                              DynsToIboCreateMapper dynsToIboCreateMapper,
                              ObjectMapper objectMapper) {
        this.username = props.auth().username();
        this.password = props.auth().password();
        this.pathDisputeLookup = props.paths().lookupDisputes();
        this.pathDisputeFolderCreate = props.paths().disputeCreate();
        this.pathLookupTransactionId = props.paths().lookupTransactionid();
        this.webClient = webClient;
        this.disputeCreateRequestDtoMapper = disputeCreateRequestDtoMapper;
        this.dynsToIboCreateMapper = dynsToIboCreateMapper;
        this.objectMapper = objectMapper;
    }

    /**
     * {@inheritDoc}
     * Führt eine Abfrage eines Dispute-Ordners anhand der übergebenen Issuer-ID und Kartenreferenz durch.
     */
    @Override
    public DisputeLookupResponseDto lookupDisputeFolder(String issuerId, String cardReference) {

        String basicAuth = Base64.getEncoder().encodeToString(
                (username + ":" + password).getBytes(StandardCharsets.UTF_8)
        );

        String json = webClient.get()
                .uri(uriBuilder -> {
                    URI builder = uriBuilder
                            .path(pathDisputeLookup)
                            .build(issuerId, cardReference);
                    return builder;
                })
                .header("WL-Correlation-ID", "pkptuna-" + System.currentTimeMillis())
                .header("WL-Origin", "pkptuna-service")
                .header(HttpHeaders.AUTHORIZATION, "Basic " + basicAuth)
                .retrieve()
                .bodyToMono(String.class)
                .block();

        DisputeLookupIboResponseDto.Builder disputeLookupIboResponseDtoBuilder =
                DisputeLookupIboResponseDto.newBuilder();
        ProtobufJsonUtil.parseJsonToProto(json, disputeLookupIboResponseDtoBuilder);

        List<DisputeFolderEntryDto> folderEntries = disputeLookupIboResponseDtoBuilder.getDataList().stream()
                .map(data -> DisputeFolderEntryDto.newBuilder()
                        .setDisputeFolderReference(data.getDisputeFolderIdentifier().getDisputeFolderReference())
                        .setStatusCode(data.getStatusCode())
                        .build())
                .collect(Collectors.toList());

        return DisputeLookupResponseDto.newBuilder()
                .setDisputeFolderExists(!folderEntries.isEmpty())
                .addAllDisputeFolders(folderEntries)
                .build();

    }

    /**
     * {@inheritDoc}
     * <p>
     * Implementierungsschritte:
     * <ol>
     *   <li>Wandelt das eingehende Protobuf-DTO in das REST-DTO für den IBO-Service um.</li>
     *   <li>Ermittelt über die Acquirer Reference Number (ARN) die zugehörige Transaktions-ID
     *       durch einen Lookup beim externen Service.</li>
     *   <li>Führt eine fachliche Validierung der Eingabedaten durch und normalisiert diese ggf.</li>
     *   <li>Mappt die normalisierten Daten auf das IBO-spezifische Create-Request-DTO.</li>
     *   <li>Sendet die Create-Anfrage an den IBO-Service und prüft die Antwort auf Erfolg.</li>
     *   <li>Extrahiert und liefert die vom IBO-System vergebene DisputeFolderReference zurück.</li>
     * </ol>
     *
     * @throws osplus.pkptuna.dispute.service.validation.FunctionalValidationException
     *         wenn die fachliche Validierung fehlschlägt
     * @throws RuntimeException wenn Pflichtdaten fehlen, externe Aufrufe fehlschlagen
     *         oder die Antwort ungültig ist
     */
    @Override
    public DisputeCreateResponseDto createDispute(DisputeCreateRequestDto disputeCreateRequestDto) {

        // Proto -> REST for the external REST contract
        osplus.pkptuna.rest.dispute.create.model.DisputeCreateRequestDto disputeCreateRequestDtoMapperRestDto =
                disputeCreateRequestDtoMapper.toRestDto(disputeCreateRequestDto);

        // ---------------------- 1) Lookup transactionId from ARN ----------------------
        Integer issuerId = Optional.ofNullable(disputeCreateRequestDtoMapperRestDto.getIssuerId())
                .orElseThrow(() -> new RuntimeException("IssuerId is not present"));

        String arn = Optional.ofNullable(disputeCreateRequestDtoMapperRestDto.getAcquirerReferenceData())
                .orElseThrow(() -> new RuntimeException("acquiringReferenceNumber is not present"));

        DisputeIboTransactionRequestDto txReq = new DisputeIboTransactionRequestDto();
        txReq.setIssuerId(issuerId.toString());
        txReq.setAcquirerReferenceDataList(java.util.List.of(arn));

        DisputeIboTransactionResponseDto txResp = lookUpIboTransactionId(txReq);

        ensureOk(txResp.getResponseMetadata(), "Exception in fetching transaction identifier");

        // Extract transactionId
        String transactionId = Optional.ofNullable(txResp.getData())
                .filter(list -> !list.isEmpty())
                .map(list -> list.get(0))
                .map(d -> d.getTransactionIdentifier())
                .map(ti -> ti.getTransactionId())
                .filter(id -> id != null && !id.isBlank())
                .orElseThrow(() -> new RuntimeException("Transaction identifier not found"));

        // ---------------------- 2) Build IBO create request body ----------------------
        List<Violation> violations = DisputeCreateValidator.validate(disputeCreateRequestDtoMapperRestDto);
        if (!violations.isEmpty()) {
            throw new FunctionalValidationException(violations);
        }

        osplus.pkptuna.rest.dispute.create.model.DisputeCreateRequestDto normalizedDisputeCreateRequestRestDto
                = DisputeCreateNormalizer.normalize(disputeCreateRequestDtoMapperRestDto);

        DisputeIboCreateRequestDto iboCreateBody = dynsToIboCreateMapper.toIbo(normalizedDisputeCreateRequestRestDto);

        // ---------------------- 3) Create the dispute in IBO ----------------------
        DisputeIboCreateResponseDto createResp = createIboDispute(issuerId.toString(), transactionId, iboCreateBody);

        ensureOk(createResp.getResponseMetadata(), "Create dispute failed");

        // Extract disputeFolderReference
        String disputeFolderReference = Optional.ofNullable(createResp.getData())
                .map(d -> d.getDisputeFolderIdentifier())
                .map(id -> id.getDisputeFolderReference())
                .filter(ref -> ref != null && !ref.isBlank())
                .orElseThrow(() -> new RuntimeException("Missing disputeFolderReference in create response"));

        // ---------------------- 4) Build service response ----------------------
        DisputeCreateResponseDto.Builder out = DisputeCreateResponseDto.newBuilder()
                .setReklVgngIntnNr(disputeFolderReference);

        return out.build();
    }

    /**
     * Führt den HTTP-Aufruf an den IBO-Service zum Erstellen eines neuen Dispute-Ordners durch.
     *
     * @param issuerId       die ID des Issuers
     * @param transactionId  die zuvor ermittelte Transaktions-ID
     * @param body           das IBO-spezifische Create-Request-DTO mit den Dispute-Daten
     * @return die vom IBO-Service gelieferte Antwort als {@link DisputeIboCreateResponseDto}
     *
     * @throws RuntimeException wenn der HTTP-Aufruf fehlschlägt oder die Antwort ungültig ist
     */
    private DisputeIboCreateResponseDto createIboDispute(String issuerId,
                                                         String transactionId,
                                                         DisputeIboCreateRequestDto body) {
        String basicAuth = Base64.getEncoder().encodeToString((username + ":" + password).getBytes(StandardCharsets.UTF_8));

        return webClient.post()
                .uri(uriBuilder -> uriBuilder.path(pathDisputeFolderCreate).build(issuerId, transactionId))
                .header("WL-Correlation-ID", "pkptuna-" + System.currentTimeMillis())
                .header("WL-Origin", "pkptuna-service")
                .header(HttpHeaders.AUTHORIZATION, "Basic " + basicAuth)
                .header(HttpHeaders.CONTENT_TYPE, "application/json")
                .header(HttpHeaders.ACCEPT, "application/json")
                .bodyValue(body)
                .exchangeToMono(resp -> resp.bodyToMono(String.class).defaultIfEmpty("")
                        .map(raw -> {
                            final int sc = resp.statusCode().value();
                            final String corr = headerOrEmpty(resp.headers().asHttpHeaders(), "WL-Correlation-ID");

                            try {
                                // Try full parse of body (works for both 2xx and non-2xx if server returns JSON)
                                if (!raw.isBlank()) {
                                    DisputeIboCreateResponseDto parsed =
                                            objectMapper.readValue(raw, DisputeIboCreateResponseDto.class);

                                    // ensure metadata at least contains HTTP status/corr if server left them empty
                                    if (parsed.getResponseMetadata() != null) {
                                        if (parsed.getResponseMetadata().getStatusCode() == 0) {
                                            parsed.getResponseMetadata().setStatusCode(sc);
                                        }
                                        if (parsed.getResponseMetadata().getCorrelationId() == null
                                                || parsed.getResponseMetadata().getCorrelationId().isBlank()) {
                                            parsed.getResponseMetadata().setCorrelationId(corr);
                                        }
                                        return parsed;
                                    }
                                }
                            } catch (Exception parseErr) {
                                LOGGER.debug("Could not parse IBO create response body as DTO. status={}, corrId={}, body={}",
                                        sc, corr, raw);
                            }

                            // Fallback: synthesize a minimal response with metadata
                            osplus.pkptuna.rest.dispute.ibo.create.model.ResponseMetadataDto md =
                                    new osplus.pkptuna.rest.dispute.ibo.create.model.ResponseMetadataDto();
                            md.setCorrelationId(corr);
                            md.setStatusCode(sc);
                            md.setStatusMessage(raw.isBlank() ? "No body" : raw);
                            md.setResponseDateTime(java.time.OffsetDateTime.now().toString());
                            md.setTimeTakenMs(0L);

                            DisputeIboCreateResponseDto fallback = new DisputeIboCreateResponseDto();
                            fallback.setResponseMetadata(md);
                            return fallback;
                        }))
                .block();
    }

    /**
     * Führt den HTTP-Aufruf an den IBO-Service durch, um anhand der übergebenen ARN (Acquirer Reference Number)
     * die zugehörige Transaktions-ID zu ermitteln.
     *
     * @param req das {@link DisputeIboTransactionRequestDto} mit Issuer-ID und ARN-Liste
     * @return die vom IBO-Service gelieferte Antwort als {@link DisputeIboTransactionResponseDto}
     *
     * @throws RuntimeException wenn der HTTP-Aufruf fehlschlägt oder die Antwort ungültig ist
     */
    private DisputeIboTransactionResponseDto lookUpIboTransactionId(DisputeIboTransactionRequestDto req) {
        String basicAuth = Base64.getEncoder().encodeToString((username + ":" + password).getBytes(StandardCharsets.UTF_8));

        return webClient.post()
                .uri(uriBuilder -> uriBuilder.path(pathLookupTransactionId)
                        .queryParam("filter", "transactionIdentifier.transactionId")
                        .build())
                .header("WL-Correlation-ID", "pkptuna-" + System.currentTimeMillis())
                .header("WL-Origin", "pkptuna-service")
                .header(HttpHeaders.AUTHORIZATION, "Basic " + basicAuth)
                .header(HttpHeaders.CONTENT_TYPE, "application/json")
                .header(HttpHeaders.ACCEPT, "application/json")
                .bodyValue(req)
                .exchangeToMono(resp -> resp.bodyToMono(String.class).defaultIfEmpty("")
                        .map(raw -> {
                            final int sc = resp.statusCode().value();
                            final String corr = headerOrEmpty(resp.headers().asHttpHeaders(), "WL-Correlation-ID");

                            try {
                                if (!raw.isBlank()) {
                                    DisputeIboTransactionResponseDto parsed =
                                            objectMapper.readValue(raw, DisputeIboTransactionResponseDto.class);

                                    if (parsed.getResponseMetadata() != null) {
                                        if (parsed.getResponseMetadata().getStatusCode() == 0) {
                                            parsed.getResponseMetadata().setStatusCode(sc);
                                        }
                                        if (parsed.getResponseMetadata().getCorrelationId() == null
                                                || parsed.getResponseMetadata().getCorrelationId().isBlank()) {
                                            parsed.getResponseMetadata().setCorrelationId(corr);
                                        }
                                        return parsed;
                                    }
                                }
                            } catch (Exception parseErr) {
                                String arn = (req.getAcquirerReferenceDataList() != null
                                        && !req.getAcquirerReferenceDataList().isEmpty())
                                        ? req.getAcquirerReferenceDataList().get(0) : "<none>";
                                LOGGER.debug("Could not parse IBO tx lookup body. status={}, corrId={}, issuerId={}, arn={}, body={}",
                                        sc, corr, req.getIssuerId(), arn, raw);
                            }

                            osplus.pkptuna.rest.dispute.ibo.transaction.identifier.model.ResponseMetadataDto md =
                                    new osplus.pkptuna.rest.dispute.ibo.transaction.identifier.model.ResponseMetadataDto();
                            md.setCorrelationId(corr);
                            md.setStatusCode(sc);
                            md.setStatusMessage(raw.isBlank() ? "No body" : raw);
                            md.setResponseDateTime(java.time.OffsetDateTime.now().toString());
                            md.setTimeTakenMs(0L);

                            DisputeIboTransactionResponseDto fallback = new DisputeIboTransactionResponseDto();
                            fallback.setResponseMetadata(md);
                            return fallback;
                        }))
                .block();
    }

    /**
     * Prüft, ob die in der Antwort enthaltenen Metadaten einen erfolgreichen HTTP-Statuscode enthalten.
     *
     * @param md  das Response-Metadatenobjekt der Transaktions-Lookup-Antwort
     * @param ctx zusätzlicher Kontexttext für Logging und Fehlermeldungen
     * @throws RuntimeException wenn {@code md} {@code null} ist oder der Statuscode kein 2xx-Code ist
     */
    private static void ensureOk(osplus.pkptuna.rest.dispute.ibo.transaction.identifier.model.ResponseMetadataDto md, String ctx) {
        if (md == null) {
            throw new RuntimeException(ctx + " (no response metadata)");
        }
        int code = md.getStatusCode();
        if (code < 200 || code >= 300) {
            LoggerFactory.getLogger(DisputeServiceImpl.class)
                    .error("{} – IBO metadata: status={}, corrId={}, msg={}",
                            ctx, code, (md.getCorrelationId() == null ? "" : md.getCorrelationId()), md.getStatusMessage());
            throw new RuntimeException(ctx + " (status=" + code + ", corrId=" + (md.getCorrelationId() == null ? "" : md.getCorrelationId()) + "): " + md.getStatusMessage());
        }
    }

    /**
     * Prüft, ob die in der Antwort enthaltenen Metadaten einen erfolgreichen HTTP-Statuscode enthalten.
     *
     * @param md  das Response-Metadatenobjekt der Dispute-Create-Antwort
     * @param ctx zusätzlicher Kontexttext für Logging und Fehlermeldungen
     * @throws RuntimeException wenn {@code md} {@code null} ist oder der Statuscode kein 2xx-Code ist
     */
    private static void ensureOk(osplus.pkptuna.rest.dispute.ibo.create.model.ResponseMetadataDto md, String ctx) {
        if (md == null) {
            throw new RuntimeException(ctx + " (no response metadata)");
        }
        int code = md.getStatusCode();
        if (code < 200 || code >= 300) {
            LoggerFactory.getLogger(DisputeServiceImpl.class)
                    .error("{} – IBO metadata: status={}, corrId={}, msg={}",
                            ctx, code, (md.getCorrelationId() == null ? "" : md.getCorrelationId()), md.getStatusMessage());
            throw new RuntimeException(ctx + " (status=" + code + ", corrId=" + (md.getCorrelationId() == null ? "" : md.getCorrelationId()) + "): " + md.getStatusMessage());
        }
    }

    /**
     * Liest den angegebenen HTTP-Headerwert aus oder gibt einen leeren String zurück,
     * falls der Header nicht vorhanden oder {@code null} ist.
     *
     * @param h    die HttpHeaders-Instanz
     * @param name der Name des gesuchten Headers
     * @return der erste gefundene Headerwert oder ein leerer String, wenn nicht vorhanden
     */
    private static String headerOrEmpty(org.springframework.http.HttpHeaders h, String name) {
        return (h != null) ? Optional.ofNullable(h.getFirst(name)).orElse("") : "";
    }
}
