package osplus.pkp.dto.util;

import freemarker.template.Template;
import freemarker.template.TemplateException;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Map;

/**
 * Hilfsklasse zum Schreiben von FreeMarker-Templates auf eine Datei.
 * Kapselt das Filehandling und Fehlerprotokollierung.
 */
public final class TemplateWriterUtil {

    private static final Logger LOGGER = LoggerFactory.getLogger(TemplateWriterUtil.class);

    private TemplateWriterUtil() {
        // Verhindert Instanziierung
    }

    /**
     * Schreibt ein FreeMarker-Template mit dem gegebenen Datenmodell in die Ausgabedatei.
     *
     * @param template   Das zu verwendende FreeMarker-Template
     * @param dataModel  Das Datenmodell (Map), das im Template ersetzt wird
     * @param outputFile Die Ausgabedatei
     */
    public static void writeTemplate(Template template, Map<String, Object> dataModel, File outputFile) {
        try (Writer writer = new BufferedWriter(new FileWriter(outputFile))) {
            template.process(dataModel, writer);
            LOGGER.info("Datei erfolgreich generiert: {}", outputFile.getAbsolutePath());
        } catch (IOException | TemplateException e) {
            LOGGER.error("Fehler beim Schreiben der Datei: {}", outputFile.getName(), e);
        }
    }
}

--------------

package osplus.pkp.dto.util;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import freemarker.template.Version;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Testklasse für {@link TemplateWriterUtil}.
 * Verifiziert das Schreiben von Templates mit und ohne Inhalt.
 */
class TemplateWriterUtilTest {

    private File tempDir;

    /**
     * Erstellt ein temporäres Verzeichnis für Ausgabedateien.
     *
     * @throws Exception falls das Verzeichnis nicht erstellt werden kann
     */
    @BeforeEach
    void setUp() throws Exception {
        tempDir = Files.createTempDirectory("template-util-test").toFile();
    }

    /**
     * Löscht temporäre Testdateien nach jedem Testfall.
     */
    @AfterEach
    void tearDown() {
        File[] files = tempDir.listFiles();
        if (files != null) {
            for (File file : files) {
                file.delete();
            }
        }
        tempDir.delete();
    }

    /**
     * Testet das Schreiben eines einfachen Templates mit einem Datenmodell.
     *
     * @throws Exception falls eine Template-Fehlkonfiguration auftritt
     */
    @Test
    void testWriteTemplateSuccessfully() throws Exception {
        // FreeMarker-Konfiguration für Tests
        Configuration cfg = new Configuration(new Version("2.3.32"));
        cfg.setClassForTemplateLoading(this.getClass(), "/");
        cfg.setDefaultEncoding("UTF-8");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

        // Temporäres Template als String simulieren
        File templateFile = new File(tempDir, "simple.ftl");
        Files.writeString(templateFile.toPath(), "Hallo ${name}!");

        // Template laden
        Template template = cfg.getTemplate("template-util-test/simple.ftl");

        Map<String, Object> dataModel = new HashMap<>();
        dataModel.put("name", "Welt");

        File output = new File(tempDir, "output.txt");
        TemplateWriterUtil.writeTemplate(template, dataModel, output);

        assertTrue(output.exists());
        String content = Files.readString(output.toPath());
        assertTrue(content.contains("Hallo Welt"));
    }
}
