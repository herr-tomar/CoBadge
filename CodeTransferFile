package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import osplus.pkptuna.hazelcast.config.FlowConfig;
import osplus.pkptuna.hazelcast.config.PubSubConfig;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.flows.FlowHandlerRegistry;

import java.util.List;
import java.util.UUID;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.startsWith;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class GenericHazelcastRouterTest {

    private HazelcastInstance hazelcastInstance;
    private FlowHandlerRegistry handlerRegistry;
    private FlowHandler<Object, Object> handler;

    private ITopic topic;
    private IMap leaderMap;
    private IMap heartbeatMap;
    private IMap routerMap;
    private IMap targetMap;

    private PubSubConfig pubSubConfig;

    private FlowConfig config;
    private GenericHazelcastRouter router;
    private final String routerInstanceId = "instance-A";

    @BeforeEach
    public void setup() {
        hazelcastInstance = mock(HazelcastInstance.class);
        handlerRegistry = mock(FlowHandlerRegistry.class);
        handler = mock(FlowHandler.class);

        topic = mock(ITopic.class);
        leaderMap = mock(IMap.class);
        heartbeatMap = mock(IMap.class);
        routerMap = mock(IMap.class);
        targetMap = mock(IMap.class);

        pubSubConfig = mock(PubSubConfig.class);

        config = mock(FlowConfig.class);
        when(config.name()).thenReturn("myFlow");
        when(config.requestTopic()).thenReturn("topic1");
        when(config.mapBase()).thenReturn("map-");
        when(config.partitions()).thenReturn(2);

        when(handlerRegistry.getHandler("myFlow")).thenReturn(handler);
        when(hazelcastInstance.getReliableTopic("topic1")).thenReturn(topic);
        when(hazelcastInstance.getMap("router-leader-map")).thenReturn(leaderMap);
        when(hazelcastInstance.getMap("router-heartbeat-map")).thenReturn(heartbeatMap);
        when(hazelcastInstance.getMap("router-claim-map")).thenReturn(routerMap);
        when(hazelcastInstance.getMap(startsWith("map-"))).thenReturn(targetMap);

        // Setup: force leadership by simulating stale heartbeat and no current leader
        when(heartbeatMap.get("heartbeat")).thenReturn(null);
        when(leaderMap.get("active-router")).thenReturn(null);
        when(leaderMap.putIfAbsent(eq("active-router"), eq(routerInstanceId))).thenReturn(null);

        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry, pubSubConfig);

        router.setRouterInstanceId(routerInstanceId);
    }

    @Test
    public void testMessageRoutedSuccessfully() throws Exception {
        router.initRouters();

        byte[] rawMessage = "test".getBytes();
        Object deserialized = new Object();
        String corrId = UUID.randomUUID().toString();

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);
        when(routerMap.putIfAbsent(eq("route-lock-" + corrId), anyString())).thenReturn(null);

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<MessageListener<byte[]>> captor = ArgumentCaptor.forClass(MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(targetMap).put(eq(corrId), eq(deserialized));
    }

    @Test
    public void testDuplicateMessageNotProcessed() throws Exception {
        router.initRouters();

        byte[] rawMessage = "test".getBytes();
        Object deserialized = new Object();
        String corrId = "duplicate-id";

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);
        when(routerMap.putIfAbsent(eq("route-lock-" + corrId), anyString())).thenReturn("alreadyExists");

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<MessageListener<byte[]>> captor = ArgumentCaptor.forClass(MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(targetMap, never()).put(anyString(), any());
    }

    @Test
    public void testRoutingHandlerThrowsException() throws Exception {
        router.initRouters();

        byte[] rawMessage = "bad".getBytes();
        when(handler.deserializeRequest(rawMessage)).thenThrow(new RuntimeException("Failed"));

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<MessageListener<byte[]>> captor = ArgumentCaptor.forClass(MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(routerMap, never()).putIfAbsent(anyString(), anyString());
        verify(targetMap, never()).put(anyString(), any());
    }

    @Test
    public void testNotLeaderDoesNotSubscribeToTopics() {
        // Simulate: heartbeat is valid and another router is active
        when(heartbeatMap.get("heartbeat")).thenReturn(System.currentTimeMillis());
        when(leaderMap.get("active-router")).thenReturn("instance-B");

        router.initRouters();

        verify(topic, never()).addMessageListener(any());
    }
}
