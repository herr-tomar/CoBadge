package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import osplus.pkptuna.hazelcast.config.FlowConfig;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.flows.FlowHandlerRegistry;

import java.util.List;
import java.util.UUID;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.startsWith;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class GenericHazelcastRouterTest {

    private HazelcastInstance hazelcastInstance;
    private FlowHandlerRegistry handlerRegistry;
    private FlowHandler<Object, Object> handler;

    @SuppressWarnings("rawtypes")
    private ITopic topic;
    @SuppressWarnings("rawtypes")
    private IMap routerMap;
    @SuppressWarnings("rawtypes")
    private IMap targetMap;
    private IMap leaderMap;

    private FlowConfig config;

    private GenericHazelcastRouter router;

    @BeforeEach
    public void setup() {
        hazelcastInstance = mock(HazelcastInstance.class);
        handlerRegistry = mock(FlowHandlerRegistry.class);
        handler = mock(FlowHandler.class);

        // Mock maps and topic
        topic = mock(ITopic.class);
        routerMap = mock(IMap.class);
        targetMap = mock(IMap.class);

        // Mock FlowConfig
        config = mock(FlowConfig.class);
        when(config.name()).thenReturn("myFlow");
        when(config.requestTopic()).thenReturn("topic1");
        when(config.mapBase()).thenReturn("map-");
        when(config.partitions()).thenReturn(2);

        // Return mocked handler from registry
        when(handlerRegistry.getHandler("myFlow")).thenReturn(handler);

        // Return the mocked topic for the configured topic name
        when(hazelcastInstance.getReliableTopic("topic1")).thenReturn((ITopic) topic);

        // Set up leader and routing maps
        IMap leaderMap = mock(IMap.class);
        when(hazelcastInstance.getMap("router-leader-map")).thenReturn(leaderMap);
        when(hazelcastInstance.getMap("router-claim-map")).thenReturn((IMap) routerMap);

        // Return target map for dynamic partition maps
        when(hazelcastInstance.getMap(startsWith("map-"))).thenReturn((IMap) targetMap);

        // Simulate that this instance IS the leader by default
        String testRouterInstanceId = "instance-A";
        when(leaderMap.get("leader-myFlow")).thenReturn(testRouterInstanceId);

        // Inject fixed routerInstanceId to GenericHazelcastRouter
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry, testRouterInstanceId);
    }

    @Test
    public void testMessageRoutedSuccessfully() throws Exception {

        // Given: A router instance that is NOT the leader
        String testInstanceId = "instance-A";

        // Override the leaderMap behavior
        IMap<String, String> leaderMap =  hazelcastInstance.getMap("router-leader-map");
        when(leaderMap.get("leader-myFlow")).thenReturn(testInstanceId);

        // Recreate router with overridden leader ID
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry, testInstanceId);
        router.initRouters();

        byte[] rawMessage = "data".getBytes();
        Object deserialized = new Object();
        String corrId = UUID.randomUUID().toString();

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);
        when(routerMap.putIfAbsent(eq("route-lock-" + corrId), anyString())).thenReturn(null);

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<com.hazelcast.topic.MessageListener<byte[]>> captor = ArgumentCaptor.forClass(com.hazelcast.topic.MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(targetMap).put(eq(corrId), eq(deserialized));
    }

    @Test
    public void testDuplicateMessageNotProcessed() throws Exception {
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry);
        router.initRouters();

        byte[] rawMessage = "data".getBytes();
        Object deserialized = new Object();
        String corrId = "duplicate-id";

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);
        when(routerMap.putIfAbsent(eq("route-lock-" + corrId), anyString())).thenReturn("alreadyExists");

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<com.hazelcast.topic.MessageListener<byte[]>> captor = ArgumentCaptor.forClass(com.hazelcast.topic.MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(targetMap, never()).put(anyString(), any());
    }

    @Test
    public void testRoutingHandlerThrowsException() throws Exception {
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry);
        router.initRouters();

        byte[] rawMessage = "data".getBytes();

        when(handler.deserializeRequest(rawMessage)).thenThrow(new RuntimeException("Handler failure"));

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<com.hazelcast.topic.MessageListener<byte[]>> captor = ArgumentCaptor.forClass(com.hazelcast.topic.MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(routerMap, never()).putIfAbsent(anyString(), anyString());
        verify(targetMap, never()).put(anyString(), any());
    }

    @Test
    public void testNotLeaderDoesNotProcessMessage() throws Exception {
        // Given: A router instance that is NOT the leader
        String testInstanceId = "instance-A";
        String testLeaderId = "instance-B"; // different than instance-A

        // Override the leaderMap behavior
        IMap<String, String> leaderMap =  hazelcastInstance.getMap("router-leader-map");
        when(leaderMap.get("leader-myFlow")).thenReturn(testLeaderId);

        // Recreate router with overridden leader ID
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry, testInstanceId);
        router.initRouters();

        // Prepare test message
        byte[] rawMessage = "data".getBytes();
        Object deserialized = new Object();
        String corrId = "test-corr-id";

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);

        // Fire message
        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<MessageListener<byte[]>> captor = ArgumentCaptor.forClass(MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        // Then: Nothing should be routed
        verify(routerMap, never()).putIfAbsent(anyString(), anyString());
        verify(targetMap, never()).put(anyString(), any());
    }
}
