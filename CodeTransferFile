package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.topic.ITopic;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import osplus.apl.core.test.utils.AplTestRunner;
import osplus.apl.core.test.utils.BaseAplTest;
import osplus.pkptuna.hazelcast.config.FlowConfig;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.flows.FlowHandlerRegistry;
import osplus.pkptuna.hazelcast.test.config.FlowHandlerTestConfiguration;

import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(
        classes = {AplTestRunner.class, FlowHandlerTestConfiguration.class},
        webEnvironment = SpringBootTest.WebEnvironment.MOCK,
        properties = {
                "spring.main.allow-bean-definition-overriding=true",
                "generichazelcast.polling-rate=20",
                "apl.application.name=uui",
                "apl.application.version=0.0.1-TEST"
        }
)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class GenericHazelcastRouterTest extends BaseAplTest {

    @Autowired
    private HazelcastInstance hazelcastInstance;

    @Autowired
    private FlowHandlerRegistry<String, FlowHandler> handlerRegistry;

    @Autowired
    private FlowHandler sampleFlowHandler;

    @Autowired
    private FlowConfig flowConfig;

    @Autowired
    private GenericHazelcastRouter router;

    private IMap<String, String> leaderMap;
    private IMap<String, Long> heartbeatMap;
    private IMap<String, String> routerMap;
    private IMap<Object, Object> targetMap;
    private ITopic<byte[]> topic;

    private final String routerInstanceId = "test-router-instance";

    @BeforeEach
    public void setup() {
        leaderMap = hazelcastInstance.getMap("router-leader-map");
        heartbeatMap = hazelcastInstance.getMap("router-heartbeat-map");
        routerMap = hazelcastInstance.getMap("router-claim-map");
        targetMap = hazelcastInstance.getMap("map-0");
        topic = hazelcastInstance.getReliableTopic("req-topic");

        leaderMap.clear();
        heartbeatMap.clear();
        routerMap.clear();
        targetMap.clear();

        router.setRouterInstanceId(routerInstanceId);
    }

    @Test
    public void testMessageRoutedSuccessfully() throws Exception {
        router.initRouters();

        Map<String, Object> requestMap = Map.of("foo", "bar");
        byte[] rawMessage = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsBytes(requestMap);

        String expectedCorrelationId = sampleFlowHandler.extractCorrelationId(requestMap);

        topic.publish(rawMessage);
        Thread.sleep(500); // allow routing to complete

        assertTrue(targetMap.containsKey(expectedCorrelationId), "Expected message to be routed to target map");
        assertEquals(requestMap, targetMap.get(expectedCorrelationId));
    }

    @Test
    public void testDuplicateMessageNotProcessed() throws Exception {
        router.initRouters();

        Map<String, Object> requestMap = Map.of("dup", "check");
        byte[] rawMessage = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsBytes(requestMap);
        String corrId = sampleFlowHandler.extractCorrelationId(requestMap);

        routerMap.put("route-lock-" + corrId, "existing"); // simulate lock already taken

        topic.publish(rawMessage);
        Thread.sleep(500);

        assertFalse(targetMap.containsKey(corrId), "Duplicate message should not be routed");
    }

    @Test
    public void testRoutingHandlerThrowsException() throws Exception {
        router.initRouters();

        String faulty = "faultyRequest";
        byte[] rawMessage = faulty.getBytes();

        topic.publish(rawMessage);
        Thread.sleep(500);

        assertTrue(routerMap.isEmpty(), "No lock should be acquired on handler failure");
        assertTrue(targetMap.isEmpty(), "Faulty request should not be routed");
    }

    @Test
    public void testNotLeaderDoesNotSubscribeToTopics() {
        heartbeatMap.put("heartbeat", System.currentTimeMillis());
        leaderMap.put("active-router", "some-other-instance");

        router.initRouters();

        // Publish a message, but router should not be listening
        topic.publish("irrelevant".getBytes());

        // Delay to ensure nothing processed
        try {
            Thread.sleep(500);
        } catch (InterruptedException ignored) {}

        assertTrue(targetMap.isEmpty(), "Non-leader should not route messages");
    }
}
