package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import osplus.pkptuna.hazelcast.config.FlowConfig;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.flows.FlowHandlerRegistry;

import java.util.List;
import java.util.UUID;

import static org.mockito.Mockito.*;

public class GenericHazelcastRouterTest {

    private HazelcastInstance hazelcastInstance;
    private FlowHandlerRegistry handlerRegistry;
    private FlowHandler<Object, Object> handler;

    @SuppressWarnings("rawtypes")
    private ITopic topic;
    @SuppressWarnings("rawtypes")
    private IMap routerMap;
    @SuppressWarnings("rawtypes")
    private IMap targetMap;

    private FlowConfig config;

    private GenericHazelcastRouter router;

    @BeforeEach
    public void setup() {
        hazelcastInstance = mock(HazelcastInstance.class);
        handlerRegistry = mock(FlowHandlerRegistry.class);
        handler = mock(FlowHandler.class);

        topic = mock(ITopic.class);
        routerMap = mock(IMap.class);
        targetMap = mock(IMap.class);

        config = mock(FlowConfig.class);
        when(config.name()).thenReturn("myFlow");
        when(config.requestTopic()).thenReturn("topic1");
        when(config.mapBase()).thenReturn("map-");
        when(config.partitions()).thenReturn(2);

        when(handlerRegistry.getHandler("myFlow")).thenReturn(handler);
        when(hazelcastInstance.getReliableTopic("topic1")).thenReturn((ITopic) topic);
        when(hazelcastInstance.getMap("router-claim-map")).thenReturn((IMap) routerMap);
        when(hazelcastInstance.getMap(startsWith("map-"))).thenReturn((IMap) targetMap);
    }

    /**
     * Positiver Test: Nachricht wird korrekt verarbeitet und geroutet.
     */
    @Test
    public void testMessageRoutedSuccessfully() throws Exception {
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry);
        router.initRouters();

        byte[] rawMessage = "data".getBytes();
        Object deserialized = new Object();
        String corrId = UUID.randomUUID().toString();

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);
        when(routerMap.putIfAbsent(eq("route-lock-" + corrId), anyString())).thenReturn(null);

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<com.hazelcast.topic.MessageListener<byte[]>> captor = ArgumentCaptor.forClass(com.hazelcast.topic.MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(targetMap).put(eq(corrId), eq(deserialized));
    }

    /**
     * Negativer Test: Doppelte Nachricht wird nicht verarbeitet.
     */
    @Test
    public void testDuplicateMessageNotProcessed() throws Exception {
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry);
        router.initRouters();

        byte[] rawMessage = "data".getBytes();
        Object deserialized = new Object();
        String corrId = "duplicate-id";

        when(handler.deserializeRequest(rawMessage)).thenReturn(deserialized);
        when(handler.extractCorrelationId(deserialized)).thenReturn(corrId);
        when(routerMap.putIfAbsent(eq("route-lock-" + corrId), anyString())).thenReturn("alreadyExists");

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<com.hazelcast.topic.MessageListener<byte[]>> captor = ArgumentCaptor.forClass(com.hazelcast.topic.MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(targetMap, never()).put(anyString(), any());
    }

    /**
     * Negativer Test: Exception beim Handler wird korrekt protokolliert und Verarbeitung wird abgebrochen.
     */
    @Test
    public void testRoutingHandlerThrowsException() throws Exception {
        router = new GenericHazelcastRouter(hazelcastInstance, List.of(config), handlerRegistry);
        router.initRouters();

        byte[] rawMessage = "data".getBytes();

        when(handler.deserializeRequest(rawMessage)).thenThrow(new RuntimeException("Handler failure"));

        Message<byte[]> message = mock(Message.class);
        when(message.getMessageObject()).thenReturn(rawMessage);

        ArgumentCaptor<com.hazelcast.topic.MessageListener<byte[]>> captor = ArgumentCaptor.forClass(com.hazelcast.topic.MessageListener.class);
        verify(topic).addMessageListener(captor.capture());

        captor.getValue().onMessage(message);

        verify(routerMap, never()).putIfAbsent(anyString(), anyString());
        verify(targetMap, never()).put(anyString(), any());
    }
}
