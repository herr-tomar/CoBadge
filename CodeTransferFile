package osplus.pkptuna.dispute.service.mapping;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Map;

public final class DisputeBusinessLogic {

    private DisputeBusinessLogic() {}

    private static final Map<String, String> REASON_CODE_MAP = Map.ofEntries(
            // FI-D series
            Map.entry("FI-D0",  "UNBEKANNTER_GRUND"),
            Map.entry("FI-D1",  "MEHRFACHE_BEZAHLUNG_SERVICE_/_LEISTUNG"),
            Map.entry("FI-D2",  "GELDAUTOMATENUMSATZ_NICHT_KORREKT"),
            Map.entry("FI-D3",  "BETRAG_WEICHT_VOM_BELEG_AB"),
            Map.entry("FI-D4",  "BETRAG_IN_FALSCHER_WÄHRUNG_BELASTET"),
            Map.entry("FI-D5",  "WARE_ODER_DIENSTLEISTUNG_NICHT_ERHALTEN"),
            Map.entry("FI-D6",  "VERDACHT_AUF_MARKENFÄLSCHUNG"),
            Map.entry("FI-D7",  "GUTSCHRIFT_FEHLT_NACH_STORNIERUNG"),
            Map.entry("FI-D8",  "BELASTUNG_AUTOVERMIETUNG_/_HOTEL"),
            Map.entry("FI-D9",  "WIEDERKEHRENDE_BELASTUNGEN_/_ABO"),
            Map.entry("FI-D10", "UNBEKANNTER_UMSATZ_/_MISSBRAUCH_KARTE"),
            Map.entry("FI-D11", "SONSTIGE_GRÜNDE"),
            Map.entry("FI-D12", "INSOLVENZ"),

            // FI-V series
            Map.entry("FI-V0",  "V_UNBEKANNTER_GRUND"),
            Map.entry("FI-V1",  "V_MEHRFACHE_BEZAHLUNG_SERVICE_/_LEISTUNG"),
            Map.entry("FI-V2",  "V_GELDAUTOMATENUMSATZ_NICHT_KORREKT"),
            Map.entry("FI-V3",  "V_BETRAG_WEICHT_VOM_BELEG_AB"),
            Map.entry("FI-V4",  "V_BETRAG_IN_FALSCHER_WÄHRUNG_BELASTET"),
            Map.entry("FI-V5",  "V_WARE_ODER_DIENSTLEISTUNG_NICHT_ERHALTEN"),
            Map.entry("FI-V6",  "V_VERDACHT_AUF_MARKENFÄLSCHUNG"),
            Map.entry("FI-V7",  "V_GUTSCHRIFT_FEHLT_NACH_STORNIERUNG"),
            Map.entry("FI-V8",  "V_BELASTUNG_AUTOVERMIETUNG_/_HOTEL"),
            Map.entry("FI-V9",  "V_WIEDERKEHRENDE_BELASTUNGEN_/_ABO"),
            Map.entry("FI-V10", "V_UNBEKANNTER_UMSATZ_/_MISSBRAUCH_KARTE"),
            Map.entry("FI-V11", "V_SONSTIGE_GRÜNDE"),
            Map.entry("FI-V12", "V_INSOLVENZ")
    );

    /** Maps reklaGrundKat1 → German reason text */
    public static String translateReasonCode(String dynsCode) {
        if (dynsCode == null) {
            return null;
        }
        return REASON_CODE_MAP.getOrDefault(dynsCode, dynsCode);
    }

    /** Always returns EUR (since Dyns always delivers in EUR now) */
    public static String normalizeCurrency(String ws) {
        return ws == null ? "EUR" : ws.trim().toUpperCase();
    }

    /** Converts String → long safely (minor units) */
    public static long parseLongSafe(String s, long def) {
        try { return Long.parseLong(s.trim()); } catch (Exception e) { return def; }
    }

    public static long toCents(double amount) {
        return Math.round(amount * 100.0);
    }

    /** Product classification from sepTraExtPurp + crdAfsgBetrag  */
    public static String classifyProduct(String sepTraExtPurp, String crdAfsgBetrag) {
        double amount = 0;
        try { amount = Double.parseDouble(crdAfsgBetrag); } catch (Exception ignored) {}

        if (sepTraExtPurp == null) {
            return "";
        }

        if (sepTraExtPurp.startsWith("DCRD")){
            return "ECM";
        }
        if (sepTraExtPurp.startsWith("CDCB") ||
                sepTraExtPurp.startsWith("CDDP") ||
                sepTraExtPurp.startsWith("CDOC") ||
                sepTraExtPurp.startsWith("IDCP")) {
            return "POS";
        }
        if (sepTraExtPurp.startsWith("CDCS")){
            return "ATMmdKE";
        }
        if (sepTraExtPurp.startsWith("CDCD")) {
            return (amount == 0) ? "ATModKE" : "ATMmdKE";
        }
        return "";
    }

    /**
     * Ergebnis der Funktion ermittelnAutoErst:
     * - kennzeichen: "J" (ja, Autoerstattung) oder "N" (nein, keine Autoerstattung)
     * - betrag: ermittelter Erstattungsbetrag (2 Nachkommastellen)
     */
    public static class AutoErstattungResult {
        private final String kennzeichen;
        private final double betrag;

        public AutoErstattungResult(String kennzeichen, double betrag) {
            this.kennzeichen = kennzeichen;
            this.betrag = betrag;
        }

        public String getKennzeichen() { return kennzeichen; }
        public double getBetrag() { return betrag; }

        @Override
        public String toString() {
            return "AutoErstattungResult{" +
                    "kennzeichen='" + kennzeichen + '\'' +
                    ", betrag=" + betrag +
                    '}';
        }
    }

    /**
     * Portierung der Legacy-Funktion ermittelnAutoErst aus C nach Java.
     *
     * @param anzAutoErstattungen    Anzahl bereits durchgeführter Autoerstattungen
     * @param anzAutoErstattungenMax maximal zulässige Anzahl Autoerstattungen
     * @param dAutoErstBetragMax     maximal zulässiger Autoerstattungsbetrag
     * @param dReklaBetrag           reklamierter Betrag
     * @param reklOrigWs             Originalwährung (z. B. "EUR")
     * @param reklOrigWhks           Wechselkurs (falls nicht EUR)
     * @param dCrdEntBtrg            Entgeltbetrag
     * @param teilBtrgKz             Teilbetrags-Kennzeichen ("J" oder "N")
     * @return AutoErstattungResult mit Kennzeichen und Betrag
     */
    public static AutoErstattungResult ermittelnAutoErst(
            Integer anzAutoErstattungen,
            Integer anzAutoErstattungenMax,
            double dAutoErstBetragMax,
            double dReklaBetrag,
            String reklOrigWs,
            double reklOrigWhks,
            double dCrdEntBtrg,
            String teilBtrgKz
    ) {
        double dKurs;
        double dPruefBetrag;
        double dErstattungsBetrag;

        // Wechselkurs bestimmen:
        // Bei EUR, ISO-Code 978 oder leerem/Blank-Feld wird 1.0 angenommen,
        // ansonsten wird der übergebene Wechselkurs verwendet.
        if (isEuro(reklOrigWs)) {
            dKurs = 1.0;
        } else {
            dKurs = reklOrigWhks;
        }

        // Erstattungsbetrag unter Berücksichtigung des Teilbetrags-Kennzeichens:
        // - bei "N": voller reklamierter Betrag, Prüfwert = Betrag minus Entgelt
        // - bei "J": Betrag geteilt durch Kurs (+0,005 zur kaufmännischen Rundung)
        if ("N".equalsIgnoreCase(teilBtrgKz)) {
            dPruefBetrag = round2(dReklaBetrag - dCrdEntBtrg);
            dErstattungsBetrag = round2(dReklaBetrag);
        } else {
            dPruefBetrag = round2(dReklaBetrag / dKurs + 0.005);
            dErstattungsBetrag = round2(dPruefBetrag);
        }

        // Entscheidung über Autoerstattung:
        // Nur wenn Anzahl < Maximalanzahl und Prüfwert <= Maximalbetrag
        if (anzAutoErstattungen != null && anzAutoErstattungenMax != null
                && anzAutoErstattungen < anzAutoErstattungenMax
                && dPruefBetrag <= dAutoErstBetragMax) {
            return new AutoErstattungResult("J", dErstattungsBetrag);
        } else {
            return new AutoErstattungResult("N", 0.0);
        }
    }

    // Hilfsfunktion: Prüft, ob Währung als EUR zu behandeln ist
    private static boolean isEuro(String ws) {
        if (ws == null || ws.isEmpty()) {
            return true;   // leer = EUR
        }
        if (ws.charAt(0) == ' '){
            return true;          // führendes Leerzeichen = EUR
        }
        if (ws.length() >= 3) {
            String prefix = ws.substring(0, 3).toUpperCase();
            return "EUR".equals(prefix);
        }
        return false;
    }

    // Hilfsfunktion: Rundet kaufmännisch auf 2 Nachkommastellen
    private static double round2(double v) {
        return BigDecimal.valueOf(v)
                .setScale(2, RoundingMode.HALF_UP)
                .doubleValue();
    }
}

-----


package osplus.pkptuna.dispute.service.mapping;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.NullValuePropertyMappingStrategy;
import osplus.apl.core.api.AplComponent;
import osplus.pkptuna.rest.dispute.create.model.DisputeCreateRequestDto;
import osplus.pkptuna.rest.dispute.ibo.create.model.AmountDto;
import osplus.pkptuna.rest.dispute.ibo.create.model.DisputeEventRequestDto;
import osplus.pkptuna.rest.dispute.ibo.create.model.DisputeIboCreateRequestDto;
import osplus.pkptuna.rest.dispute.ibo.create.model.DisputePostingRequestDto;

import java.util.Collections;
import java.util.List;

/**
 * MapStruct-Mapper zur Umwandlung eines {@link osplus.pkptuna.rest.dispute.create.model.DisputeCreateRequestDto}
 * in ein {@link osplus.pkptuna.rest.dispute.ibo.create.model.DisputeIboCreateRequestDto}
 * für den Aufruf des externen IBO-Dispute-Create-Services.
 * <p>
 * Neben der direkten Feldzuordnung werden hier auch mehrere berechnete bzw. zusammengesetzte Felder
 * erzeugt, wie z.B.:
 * <ul>
 *   <li>Ermittlung des Refund/Redebit-Indikators abhängig vom Teilbetrags-Kennzeichen</li>
 *   <li>Aufbau von Betragsobjekten (Refund-Betrag, Originalbetrag) mit Währungs- und Exponentenangaben</li>
 *   <li>Erstellung von Posting- und Event-Listen je nach Vorhandensein relevanter Daten</li>
 * </ul>
 * Nicht gesetzte oder leere Quellwerte werden gemäß
 * {@link org.mapstruct.NullValuePropertyMappingStrategy#IGNORE} nicht gemappt.
 */
@AplComponent
@Mapper(componentModel = "spring",
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface DynsToIboCreateMapper {

    String ISSUER_ACCOUNT = "ISSUER_ACCOUNT";

    /**
     * Führt die Hauptabbildung von einem internen DisputeCreateRequestDto
     * auf das IBO-spezifische CreateRequestDto durch.
     * <p>
     * Neben der direkten Übernahme bestimmter Felder werden:
     * <ul>
     *   <li>Standardwerte gesetzt (z. B. declareFraudIndicator = false)</li>
     *   <li>Berechnete Felder wie refundRedebitIndicator ermittelt</li>
     *   <li>Listen für Postings, Events und Dokumente erzeugt</li>
     * </ul>
     *
     * @param src Eingangsobjekt mit Dispute-Daten
     * @return IBO-kompatibles CreateRequestDto
     */
    @Mappings({
            @Mapping(target = "disputeReason",
                    expression = "java(DisputeBusinessLogic.translateReasonCode(src.getReklaGrundKat1()))"),
            @Mapping(target = "issuerDisputeExternalReference", source = "impulsOid"),
            @Mapping(target = "declareFraudIndicator", constant = "false"),

            // LEGACY: refundRedebitIndicator must be "P", "Y", or "N"
            @Mapping(target = "refundRedebitIndicator",
                    expression = "java(calcRefundIndicator(src))"),

            // refundRedebitAmount based on autoErstattungsbetrag
            @Mapping(target = "refundRedebitAmount",
                    expression = "java(calcRefundAmount(src))"),

            @Mapping(target = "disputePostings", expression = "java(buildPostings(src))"),
            @Mapping(target = "disputeEvents", expression = "java(buildEvents(src))"),
            @Mapping(target = "disputeDocuments", expression = "java(java.util.Collections.emptyList())")
    })
    DisputeIboCreateRequestDto toIbo(DisputeCreateRequestDto src);

    /**
     * Ermittelt den Refund/Redebit-Indikator für den IBO-Dispute-Request.
     * <p>
     * Die Logik entspricht der Legacy-Implementierung:
     * <ul>
     *   <li>"N" → keine automatische Erstattung</li>
     *   <li>"P" → automatische Erstattung möglich und Teilbetragskennzeichen = 'J'</li>
     *   <li>"Y" → automatische Erstattung möglich und kein Teilbetragskennzeichen</li>
     * </ul>
     * <p>
     * Alle Eingaben werden zunächst null-sicher in Zahlenwerte konvertiert
     * (über {@link #safeInt(Integer)} und {@link #safeDouble(Double)}).
     *
     * @param s Eingabeobjekt mit Dispute-Daten
     * @return Refund-Indikator ("NONE", "PARTIAL" oder "FULL")
     */
    default String calcRefundIndicator(DisputeCreateRequestDto s) {
        if (s == null) {
            return "NONE";
        }

        DisputeBusinessLogic.AutoErstattungResult res =
                DisputeBusinessLogic.ermittelnAutoErst(
                        safeInt(s.getAnzahlAutoErstattungen()),
                        safeInt(s.getAutoErstMaxAnzahl()),
                        safeDouble(s.getAutoErstMaxBetrag()),
                        safeDouble(s.getReklaBetrag()),
                        s.getCrdVfggOrigWs(),
                        safeDouble(s.getCrdVfggOrigKurs()),
                        safeDouble(s.getCrdEntBtrg()),
                        s.getReklaTeilbetragKz()
                );

        if ("N".equals(res.getKennzeichen())){
            return "NONE";
        }
        if ("J".equals(res.getKennzeichen()) && isJ(s.getReklaTeilbetragKz())){
            return "PARTIAL";
        }
        return "FULL";
    }

    /**
     * Ermittelt den Refund/Redebit-Betrag für den IBO-Dispute-Request.
     * <p>
     * Falls keine automatische Erstattung möglich ist
     * (Kennzeichen = 'N'), wird {@code null} zurückgegeben.
     * Andernfalls wird ein {@link AmountDto} mit folgenden Eigenschaften aufgebaut:
     * <ul>
     *   <li>value → Betrag in Minor Units (z. B. Cents)</li>
     *   <li>exponent → immer 2</li>
     *   <li>isoCode → normalisierter ISO-Währungscode aus {@code reklaBetragWs}</li>
     * </ul>
     *
     * @param s Eingabeobjekt mit Dispute-Daten
     * @return Refund-Betrag als {@link AmountDto}, oder {@code null}, wenn keine Erstattung
     */
    default AmountDto calcRefundAmount(DisputeCreateRequestDto s) {
        if (s == null) {
            return null;
        }

        DisputeBusinessLogic.AutoErstattungResult res =
                DisputeBusinessLogic.ermittelnAutoErst(
                        safeInt(s.getAnzahlAutoErstattungen()),
                        safeInt(s.getAutoErstMaxAnzahl()),
                        safeDouble(s.getAutoErstMaxBetrag()),
                        safeDouble(s.getReklaBetrag()),
                        s.getCrdVfggOrigWs(),
                        safeDouble(s.getCrdVfggOrigKurs()),
                        safeDouble(s.getCrdEntBtrg()),
                        s.getReklaTeilbetragKz()
                );

        if ("N".equals(res.getKennzeichen())) {
            return null;
        }

        AmountDto a = new AmountDto();
        a.setValue(DisputeBusinessLogic.toCents(res.getBetrag()));
        a.setExponent(2);
        a.setIsoCode(DisputeBusinessLogic.normalizeCurrency(s.getReklaBetragWs()));
        return a;
    }

    /**
     * Baut die Liste der Dispute-Postings auf:
     * <ol>
     *   <li>Bevorzugt TransactionBetrag (crdVfggOrigBtrg / crdVfggOrigWs)</li>
     *   <li>Falls TransactionBetrag fehlt und Teilbetrag vorliegt → Refund-Betrag verwenden</li>
     *   <li>Falls beides fehlt → leere Liste zurückgeben</li>
     * </ol>
     *
     * @param s Dispute-Request-Daten
     * @return Liste der Posting-Einträge
     */
    default List<DisputePostingRequestDto> buildPostings(DisputeCreateRequestDto s) {
        AmountDto amt = null;
        if (s.getTransactionBetrag() != null && !isBlank(s.getCrdVfggOrigWs())) {
            amt = buildAmount(s.getTransactionBetrag(), s.getCrdVfggOrigWs());
        } else if ("J".equalsIgnoreCase(s.getReklaTeilbetragKz())
                && s.getReklaBetrag() != null && !isBlank(s.getReklaBetragWs())) {
            amt = buildAmount(s.getReklaBetrag(), s.getReklaBetragWs());
        }

        if (amt == null) {
            return Collections.emptyList();
        }

        DisputePostingRequestDto p = new DisputePostingRequestDto();
        p.setPostingAmount(amt);
        p.setImmediateReimbursement(false);
        p.setPostingTypeReference(ISSUER_ACCOUNT);
        return List.of(p);
    }

    /**
     * Erstellt eine COMMENT-Eventliste, wenn ein Teilbetrag vorliegt
     * und Betrag + Währung gesetzt sind.
     * <p>
     * Andernfalls wird eine leere Liste zurückgegeben.
     *
     * @param s Dispute-Request-Daten
     * @return Liste mit einem COMMENT-Event oder leer
     */
    default List<DisputeEventRequestDto> buildEvents(DisputeCreateRequestDto s) {
        if (!isJ(s.getReklaTeilbetragKz())) {
            return Collections.emptyList();
        }
        if (s.getReklaBetrag() == null || isBlank(s.getReklaBetragWs())) {
            return Collections.emptyList();
        }

        DisputeEventRequestDto ev = new DisputeEventRequestDto();
        ev.setType("COMMENT");
        ev.setMessage("Reklamation mit Teilbetrag i.H.v. " +
                s.getReklaBetrag() + " " + s.getReklaBetragWs());
        return List.of(ev);
    }


    // ------------------- Hilfsmethoden -------------------

    /**
     * Baut ein {@link AmountDto}-Objekt aus einem numerischen Wert und einem Währungscode.
     * <p>
     * Falls entweder {@code val} {@code null} ist oder {@code ws} leer/blank,
     * wird {@code null} zurückgegeben.
     *
     * @param val numerischer Wert (in Major Units, z. B. 10.50 für 10 EUR 50 Cent)
     * @param ws  ISO-Währungscode (z. B. "EUR")
     * @return aufgebautes {@link AmountDto} oder {@code null}, falls Eingaben fehlen
     */
    private AmountDto buildAmount(Double val, String ws) {
        if (val == null || isBlank(ws)) {
            return null;
        }
        AmountDto a = new AmountDto();
        a.setValue(DisputeBusinessLogic.toCents(val));
        a.setExponent(2);
        a.setIsoCode(DisputeBusinessLogic.normalizeCurrency(ws));
        return a;
    }

    /**
     * Prüft, ob der übergebene String gleich 'J' ist (Groß-/Kleinschreibung egal).
     *
     * @param v Eingabestring
     * @return {@code true}, falls v = 'J' (ignoring case), sonst {@code false}
     */
    default boolean isJ(String v) {
        return v != null && v.trim().equalsIgnoreCase("J");
    }

    /**
     * Prüft, ob ein String {@code null} oder nur aus Leerzeichen besteht.
     *
     * @param v Eingabestring
     * @return {@code true}, wenn leer oder {@code null}, sonst {@code false}
     */
    private boolean isBlank(String v) {
        return v == null || v.trim().isEmpty();
    }

    /**
     * Liefert einen sicheren int-Wert zurück.
     * <p>
     * Falls der Eingabewert {@code null} ist, wird 0 zurückgegeben.
     *
     * @param i Eingabe-Integer
     * @return Wert oder 0 bei {@code null}
     */
    private int safeInt(Integer i) {
        return i == null ? 0 : i;
    }

    /**
     * Liefert einen sicheren double-Wert zurück.
     * <p>
     * Falls der Eingabewert {@code null} ist, wird 0.0 zurückgegeben.
     *
     * @param d Eingabe-Double
     * @return Wert oder 0.0 bei {@code null}
     */
    private double safeDouble(Double d) {
        return d == null ? 0.0 : d;
    }
}
