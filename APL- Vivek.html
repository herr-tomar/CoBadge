@ExtendWith(MockitoExtension.class)
class DisputeDetailFlowHandlerTest {

    @Mock
    private DisputeDetailService disputeDetailService;

    @Mock
    private HazelcastInstance hazelcastInstance;

    private DisputeDetailFlowHandler handler;

    @BeforeEach
    void setUp() {
        handler = new DisputeDetailFlowHandler(disputeDetailService);
    }

    @Test
    void shouldExtractCorrelationId() {
        DisputeDetailRequestWrapperDto request = DisputeDetailRequestWrapperDto.newBuilder()
                .setCorrelationId("12345")
                .build();

        String result = handler.extractCorrelationId(request);

        assertEquals("12345", result);
    }

    @Test
    void shouldHandleRequestAndCallService() {
        DisputeDetailRequestDto payload = DisputeDetailRequestDto.newBuilder()
                .setIssuerId("issuer")
                .setDisputeFolderReference("ref")
                .setMetadata(DisputeDetailRequestMetadataDto.newBuilder().addEmbed("x"))
                .build();

        DisputeDetailRequestWrapperDto request = DisputeDetailRequestWrapperDto.newBuilder()
                .setPayload(payload)
                .build();

        DisputeResponseDto expectedResponse = DisputeResponseDto.newBuilder().build();
        when(disputeDetailService.getDisputeFolderDetails("issuer", "ref", List.of("x")))
                .thenReturn(expectedResponse);

        DisputeResponseDto response = handler.handleRequest(request);

        assertEquals(expectedResponse, response);
    }

    @Test
    void shouldWrapResponseCorrectly() {
        DisputeResponseDto response = DisputeResponseDto.newBuilder().build();
        Object wrapped = handler.wrapResponse("abc", response);

        assertTrue(wrapped instanceof DisputeDetailResponseWrapperDto);
        assertEquals("abc", ((DisputeDetailResponseWrapperDto) wrapped).getCorrelationId());
    }
}


---------

@ExtendWith(MockitoExtension.class)
class DisputeLookupFlowHandlerTest {

    @Mock
    private DisputeService disputeService;

    @Mock
    private HazelcastInstance hazelcastInstance;

    private DisputeLookupFlowHandler handler;

    @BeforeEach
    void setUp() {
        handler = new DisputeLookupFlowHandler(disputeService);
    }

    @Test
    void shouldExtractCorrelationId() {
        DisputeLookupRequestWrapperDto request = DisputeLookupRequestWrapperDto.newBuilder()
                .setCorrelationId("lookup-001")
                .build();

        String result = handler.extractCorrelationId(request);

        assertEquals("lookup-001", result);
    }

    @Test
    void shouldCallLookupService() {
        DisputeLookupRequestDto dto = DisputeLookupRequestDto.newBuilder()
                .setIssuerId("issuer")
                .setCardReference("cardRef")
                .build();

        DisputeLookupRequestWrapperDto request = DisputeLookupRequestWrapperDto.newBuilder()
                .setPayload(dto)
                .build();

        DisputeLookupResponseDto expected = DisputeLookupResponseDto.newBuilder().build();
        when(disputeService.lookupDisputeFolder("issuer", "cardRef")).thenReturn(expected);

        DisputeLookupResponseDto actual = handler.handleRequest(request);

        assertEquals(expected, actual);
    }

    @Test
    void shouldWrapResponseCorrectly() {
        DisputeLookupResponseDto response = DisputeLookupResponseDto.newBuilder().build();
        Object wrapped = handler.wrapResponse("corr-id", response);

        assertTrue(wrapped instanceof DisputeLookupResponseWrapperDto);
        assertEquals("corr-id", ((DisputeLookupResponseWrapperDto) wrapped).getCorrelationId());
    }
}

------------

package osplus.pkptuna.flows.handlers;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hazelcast.core.HazelcastInstance;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import osplus.apl.core.api.AplComponent;
import osplus.pkptuna.dispute.model.*;
import osplus.pkptuna.dispute.service.DisputeDetailService;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.protobuf.impl.ProtobufSerializer;
import osplus.pkptuna.hazelcast.pubsub.ReliableTopicPublisher;

import java.util.List;

/**
 * FlowHandler zur Verarbeitung von Detailanfragen zu Streitfällen.
 * Dieser Handler übernimmt die Deserialisierung, verarbeitet die Anfrage mit Hilfe des Services,
 * verpackt die Antwort und publiziert sie auf einem Hazelcast Topic.
 */
@AplComponent("dispute-detail")
public class DisputeDetailFlowHandler implements FlowHandler<DisputeDetailRequestWrapperDto, DisputeResponseDto> {

    private static final Logger LOGGER = LoggerFactory.getLogger(DisputeDetailFlowHandler.class);
    public static final String DISPUTE_DETAIL = "dispute-detail";

    private final DisputeDetailService disputeDetailService;

    public DisputeDetailFlowHandler(DisputeDetailService disputeService) {
        this.disputeDetailService = disputeService;
    }

    /**
     * Deserialisiert das Eingangsbytearray in ein Protobuf-Wrapping DTO.
     */
    @Override
    public DisputeDetailRequestWrapperDto deserializeRequest(byte[] data) throws InvalidProtocolBufferException {
        return DisputeDetailRequestWrapperDto.parseFrom(data);
    }

    /**
     * Extrahiert die Korrelations-ID aus dem Request.
     */
    @Override
    public String extractCorrelationId(DisputeDetailRequestWrapperDto request) {
        return request.getCorrelationId();
    }

    /**
     * Verarbeitet die Anfrage durch Aufruf des zugehörigen Services.
     */
    @Override
    public DisputeResponseDto handleRequest(DisputeDetailRequestWrapperDto request) {
        DisputeDetailRequestDto dto = request.getPayload();
        List<String> embeds = dto.getMetadata().getEmbedList();
        return disputeDetailService.getDisputeFolderDetails(dto.getIssuerId(), dto.getDisputeFolderReference(), embeds);
    }

    /**
     * Verpackt das Ergebnis zusammen mit der Korrelations-ID in ein Wrapper-Objekt.
     */
    @Override
    public Object wrapResponse(String correlationId, DisputeResponseDto result) {
        return DisputeDetailResponseWrapperDto.newBuilder()
                .setCorrelationId(correlationId)
                .setResponse(result)
                .build();
    }

    /**
     * Sendet die Antwort an das angegebene Hazelcast Topic.
     */
    @Override
    public void sendResponse(HazelcastInstance hazelcastInstance, String topicName, Object response) {
        DisputeDetailResponseWrapperDto dto = (DisputeDetailResponseWrapperDto) response;
        new ReliableTopicPublisher<>(hazelcastInstance, new ProtobufSerializer<>()).sendMessage(topicName, "DISPUTE_ROUTER", dto);
    }

    @Override
    public String getFlowName() {
        return DISPUTE_DETAIL;
    }

    @PostConstruct
    public void init() {
        LOGGER.info("DisputeDetailFlowHandler geladen und initialisiert.");
    }
}


---------------

package osplus.pkptuna.flows.handlers;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hazelcast.core.HazelcastInstance;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import osplus.apl.core.api.AplComponent;
import osplus.pkptuna.dispute.lookup.model.*;
import osplus.pkptuna.dispute.service.DisputeService;
import osplus.pkptuna.hazelcast.flows.FlowHandler;
import osplus.pkptuna.hazelcast.protobuf.impl.ProtobufSerializer;
import osplus.pkptuna.hazelcast.pubsub.ReliableTopicPublisher;

/**
 * FlowHandler zur Verarbeitung von Lookup-Anfragen zu Streitfällen.
 * Dieser Handler übernimmt die Deserialisierung, verarbeitet die Anfrage mit Hilfe des Services,
 * verpackt die Antwort und publiziert sie auf einem Hazelcast Topic.
 */
@AplComponent("dispute-lookup")
public class DisputeLookupFlowHandler implements FlowHandler<DisputeLookupRequestWrapperDto, DisputeLookupResponseDto> {

    private static final Logger LOGGER = LoggerFactory.getLogger(DisputeLookupFlowHandler.class);
    public static final String DISPUTE_LOOKUP = "dispute-lookup";

    private final DisputeService disputeService;

    public DisputeLookupFlowHandler(DisputeService disputeService) {
        this.disputeService = disputeService;
    }

    /**
     * Deserialisiert das Eingangsbytearray in ein Protobuf-Wrapping DTO.
     */
    @Override
    public DisputeLookupRequestWrapperDto deserializeRequest(byte[] data) throws InvalidProtocolBufferException {
        return DisputeLookupRequestWrapperDto.parseFrom(data);
    }

    /**
     * Extrahiert die Korrelations-ID aus dem Request.
     */
    @Override
    public String extractCorrelationId(DisputeLookupRequestWrapperDto request) {
        return request.getCorrelationId();
    }

    /**
     * Verarbeitet die Anfrage durch Aufruf des zugehörigen Services.
     */
    @Override
    public DisputeLookupResponseDto handleRequest(DisputeLookupRequestWrapperDto request) {
        DisputeLookupRequestDto dto = request.getPayload();
        return disputeService.lookupDisputeFolder(dto.getIssuerId(), dto.getCardReference());
    }

    /**
     * Verpackt das Ergebnis zusammen mit der Korrelations-ID in ein Wrapper-Objekt.
     */
    @Override
    public Object wrapResponse(String correlationId, DisputeLookupResponseDto result) {
        return DisputeLookupResponseWrapperDto.newBuilder()
                .setCorrelationId(correlationId)
                .setResponse(result)
                .build();
    }

    /**
     * Sendet die Antwort an das angegebene Hazelcast Topic.
     */
    @Override
    public void sendResponse(HazelcastInstance hazelcastInstance, String topicName, Object response) {
        DisputeLookupResponseWrapperDto dto = (DisputeLookupResponseWrapperDto) response;
        new ReliableTopicPublisher<>(hazelcastInstance, new ProtobufSerializer<>()).sendMessage(topicName, "DISPUTE_ROUTER", dto);
    }

    @Override
    public String getFlowName() {
        return DISPUTE_LOOKUP;
    }

    @PostConstruct
    public void init() {
        LOGGER.info("DisputeLookupFlowHandler geladen und initialisiert.");
    }
}
