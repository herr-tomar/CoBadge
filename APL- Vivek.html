package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import osplus.apl.core.api.AplComponent;
import osplus.pkptuna.dispute.lookup.model.DisputeLookupRequestWrapperDto;
import osplus.pkptuna.dispute.lookup.model.DisputeLookupResponseDto;
import osplus.pkptuna.dispute.lookup.model.DisputeLookupResponseWrapperDto;
import osplus.pkptuna.dispute.service.DisputeService;
import osplus.pkptuna.hazelcast.protobuf.impl.ProtobufSerializer;

import java.util.Map;

@AplComponent
@EnableScheduling
public class DisputeLookupMapConsumer {

    private static final Logger LOGGER = LoggerFactory.getLogger(DisputeLookupMapConsumer.class);
    private static final String REQUEST_MAP_NAME = "dispute-lookup-request-map";

    private final HazelcastInstance hazelcastInstance;
    private final DisputeService disputeService;
    private final CustomHazelcastReliableTopicPublisher<DisputeLookupResponseWrapperDto> responsePublisher;

    public DisputeLookupMapConsumer(HazelcastInstance hazelcastInstance,
                                    DisputeService disputeService) {
        this.hazelcastInstance = hazelcastInstance;
        this.disputeService = disputeService;
        this.responsePublisher = new CustomHazelcastReliableTopicPublisher<>(
                hazelcastInstance,
                new ProtobufSerializer<>()
        );
    }

    @PostConstruct
    public void logStartup() {
        LOGGER.info("✅ DisputeLookupMapConsumer initialized. Polling IMap: '{}'", REQUEST_MAP_NAME);
    }

    @Scheduled(fixedRate = 1000) // configurable polling interval
    public void pollMapForRequests() {
        IMap<String, DisputeLookupRequestWrapperDto> requestMap =
                hazelcastInstance.getMap(REQUEST_MAP_NAME);

        int processedCount = 0;

        for (Map.Entry<String, DisputeLookupRequestWrapperDto> entry : requestMap.entrySet()) {
            String correlationId = entry.getKey();
            DisputeLookupRequestWrapperDto request = entry.getValue();

            try {
                // Atomically claim and remove the entry to avoid race conditions
                boolean claimed = requestMap.tryRemove(correlationId);

                if (!claimed) {
                    continue; // already processed by another instance
                }

                LOGGER.debug("➡️ Processing dispute request with correlationId={}", correlationId);

                DisputeLookupResponseDto result = disputeService.lookupDisputeFolder(
                        request.getIssuerId(),
                        request.getCardReference()
                );

                DisputeLookupResponseWrapperDto response = DisputeLookupResponseWrapperDto.newBuilder()
                        .setCorrelationId(correlationId)
                        .setResponse(result)
                        .build();

                responsePublisher.sendMessage(
                        "DisputeLookupResponseReliableTopic",
                        "DISPUTE_MAP_WORKER",
                        response
                );

                LOGGER.debug("✅ Processed and removed correlationId={}", correlationId);
                processedCount++;

            } catch (Exception e) {
                LOGGER.error("❌ Error processing entry [correlationId={}]: {}", correlationId, e.getMessage(), e);
            }
        }

        if (processedCount > 0) {
            LOGGER.info("🧾 Batch processed {} requests from {}", processedCount, REQUEST_MAP_NAME);
        }
    }
}
