package osplus.pkptuna.uimodule;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.topic.ITopic;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import osplus.pkptuna.dispute.lookup.model.DisputeLookupResponseDto;
import osplus.pkptuna.dispute.model.DisputeResponseDto;
import osplus.pkptuna.dispute.service.DisputeDetailService;
import osplus.pkptuna.dispute.service.DisputeService;
import osplus.pkptuna.util.GenericResponseTracker;

import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit-Testklasse für DisputeUiModule.
 * Testet die UI-Funktionen zur Streitfallabfrage und -details im Kontext des APL-UI-Modules.
 */
class DisputeUiModuleTest {

    private DisputeUiModule disputeUiModule;
    private DisputeService disputeService;
    private DisputeDetailService disputeDetailService;
    private HazelcastInstance hazelcastInstance;

    /**
     * Initialisiert Mock-Objekte und das Test-Target vor jedem Testfall.
     */
    @BeforeEach
    void setUp() {
        disputeService = mock(DisputeService.class);
        disputeDetailService = mock(DisputeDetailService.class);
        hazelcastInstance = mock(HazelcastInstance.class);

        disputeUiModule = new DisputeUiModule(hazelcastInstance, disputeService, disputeDetailService);
        disputeUiModule.disputeDetailResponseTracker = new GenericResponseTracker<>();
        disputeUiModule.disputeLookupResponseTracker = new GenericResponseTracker<>();
    }

    /**
     * Testet die Methode zur Streitfallordner-Suche über die UI-Schnittstelle.
     */
    @Test
    void testLookupDisputeFolder() {
        DisputeLookupResponseDto responseDto = DisputeLookupResponseDto.getDefaultInstance();
        when(disputeService.lookupDisputeFolder(anyString(), anyString())).thenReturn(responseDto);

        String result = disputeUiModule.lookupDisputeFolder("issuer", "cardRef");
        assertNotNull(result);
    }

    /**
     * Testet das Abrufen von Detailinformationen eines Streitfallordners.
     */
    @Test
    void testGetDisputeDetails() {
        DisputeResponseDto responseDto = DisputeResponseDto.getDefaultInstance();
        when(disputeDetailService.getDisputeFolderDetails(anyString(), anyString(), anyList())).thenReturn(responseDto);

        String result = disputeUiModule.getDisputeDetails("issuer", "ref", "events");
        assertNotNull(result);
    }

    /**
     * Testet die Initialisierung der Antwort-Listener für Hazelcast-Themen.
     */
    @Test
    void testInitResponseListeners() {
        ITopic<byte[]> topic = mock(ITopic.class);
        when(hazelcastInstance.getReliableTopic(anyString())).thenReturn(topic);
        disputeUiModule.initResponseListeners();
        verify(hazelcastInstance, times(2)).getReliableTopic(anyString());
    }
}
-----

package osplus.pkptuna.util;

import org.junit.jupiter.api.Test;

import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit-Testklasse für den GenericResponseTracker.
 * Überprüft die Registrierung, das Abrufen und das Abschließen von Antworten über Korrelations-IDs.
 */
class GenericResponseTrackerTest {

    /**
     * Testet Registrierung und erfolgreiche Verarbeitung einer Antwort.
     */
    @Test
    void testRegisterAndComplete() throws Exception {
        GenericResponseTracker<String> tracker = new GenericResponseTracker<>();
        String correlationId = "123";

        tracker.register(correlationId);
        CompletableFuture<String> future = tracker.await(correlationId);
        tracker.complete(correlationId, "TestValue");

        assertEquals("TestValue", future.get());
    }

    /**
     * Testet, dass ein registriertes, aber nicht abgeschlossenes Future noch nicht fertig ist.
     */
    @Test
    void testAwaitWithoutComplete() {
        GenericResponseTracker<String> tracker = new GenericResponseTracker<>();
        String correlationId = "456";

        tracker.register(correlationId);
        CompletableFuture<String> future = tracker.await(correlationId);
        assertFalse(future.isDone());
    }
}

----------


package osplus.pkptuna.util;

import com.google.protobuf.Message;
import com.google.protobuf.Parser;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.MessageListener;
import org.junit.jupiter.api.Test;
import osplus.fi.core.logging.api.Logger;

import static org.mockito.Mockito.*;

/**
 * Unit-Testklasse für HazelcastListenerUtils.
 * Überprüft das Registrieren eines generischen Protobuf-Listeners auf einem Hazelcast-Topic.
 */
class HazelcastListenerUtilsTest {

    /**
     * Testet die Registrierung eines MessageListeners auf einem Mock-Topic.
     */
    @Test
    void testRegisterGenericResponseListener() {
        HazelcastInstance mockHz = mock(HazelcastInstance.class);
        ITopic<byte[]> topic = mock(ITopic.class);
        when(mockHz.getReliableTopic(anyString())).thenReturn(topic);

        @SuppressWarnings("unchecked")
        Parser<Message> parser = mock(Parser.class);
        Logger logger = mock(Logger.class);

        HazelcastListenerUtils.registerGenericResponseListener(
                mockHz,
                "testTopic",
                parser,
                msg -> "id",
                msg -> msg,
                (id, response) -> {},
                logger
        );

        verify(topic).addMessageListener(any(MessageListener.class));
    }
}
_______

package osplus.pkptuna.uimodule;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.topic.ITopic;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import osplus.apl.uui.api.MethodType;
import osplus.apl.uui.api.ServiceParam;
import osplus.apl.uui.api.UiModule;
import osplus.apl.uui.api.UiService;
import osplus.fi.core.logging.api.Logger;
import osplus.fi.core.logging.api.LoggerFactory;
import osplus.pkptuna.dispute.lookup.model.*;
import osplus.pkptuna.dispute.model.*;
import osplus.pkptuna.dispute.service.DisputeDetailService;
import osplus.pkptuna.dispute.service.DisputeService;
import osplus.pkptuna.dispute.util.ProtobufJsonUtil;
import osplus.pkptuna.util.GenericResponseTracker;
import osplus.pkptuna.util.HazelcastListenerUtils;

import java.util.*;
import java.util.concurrent.*;

/**
 * APL UI-Modul zur Bereitstellung von Funktionen zur Streitfallabfrage und Detailanzeige
 * über das APL Runtime-Framework. Nutzt Hazelcast zur asynchronen Kommunikation mit Backend-Services.
 */
@UiModule("disputeUiModule")
public class DisputeUiModule {

    private static final Logger LOGGER = LoggerFactory.getLogger(DisputeUiModule.class);

    private final DisputeService disputeService;
    private final DisputeDetailService disputeDetailService;
    private final HazelcastInstance hazelcastInstance;

    @Autowired
    private GenericResponseTracker<DisputeResponseDto> disputeDetailResponseTracker;

    @Autowired
    private GenericResponseTracker<DisputeLookupResponseDto> disputeLookupResponseTracker;

    /**
     * Konstruktor zur Initialisierung mit benötigten Services.
     *
     * @param hazelcastInstance       Hazelcast-Instanz
     * @param disputeService          Service für Streitfall-Suchlogik
     * @param disputeDetailService    Service für Detailabrufe zu Streitfällen
     */
    public DisputeUiModule(HazelcastInstance hazelcastInstance,
                           DisputeService disputeService,
                           DisputeDetailService disputeDetailService) {
        this.disputeService = disputeService;
        this.disputeDetailService = disputeDetailService;
        this.hazelcastInstance = hazelcastInstance;
    }

    /**
     * UI-Service-Endpunkt zur Prüfung, ob ein Streitfallordner existiert, und Rückgabe seiner Metadaten.
     *
     * @param issuerId      Die Kennung des Kartenherausgebers (Issuer)
     * @param cardReference Die Referenznummer der Karte
     * @return              JSON-String mit {@link DisputeLookupResponseDto}
     */
    @UiService(value = "disputeLookup", method = MethodType.GET, requiresAuthentication = false)
    public String lookupDisputeFolder(
            @ServiceParam("issuerId") String issuerId,
            @ServiceParam("cardReference") String cardReference) {

        LOGGER.info("Received lookupDisputeFolder request for issuerId={} and cardReference={}", issuerId, cardReference);
        DisputeLookupResponseDto dto = disputeService.lookupDisputeFolder(issuerId, cardReference);
        return ProtobufJsonUtil.printProtoToJson(dto);
    }

    /**
     * UI-Service-Endpunkt zum Abrufen von Detailinformationen zu einem bestimmten Streitfallordner.
     *
     * @param issuerId               Die ID des Herausgebers
     * @param disputeFolderReference Die Referenznummer des Streitfallordners
     * @param embed                  Kommagetrennte Liste (z. B. "events,documents"), was eingebettet werden soll
     * @return                       JSON-String mit {@link DisputeResponseDto}
     */
    @UiService(value = "disputeDetails", method = MethodType.GET, requiresAuthentication = false)
    public String getDisputeDetails(
            @ServiceParam("issuerId") String issuerId,
            @ServiceParam("disputeFolderReference") String disputeFolderReference,
            @ServiceParam(value = "embed") String embed) {

        LOGGER.info("Fetching dispute folder details for issuerId={} and folderRef={} with embed={}",
                issuerId, disputeFolderReference, embed);

        List<String> embedList = (embed != null && !embed.isEmpty())
                ? Arrays.asList(embed.split(","))
                : null;

        DisputeResponseDto dto = disputeDetailService.getDisputeFolderDetails(issuerId, disputeFolderReference, embedList);
        return ProtobufJsonUtil.printProtoToJson(dto);
    }

    /**
     * UI-Service-Endpunkt zur asynchronen Übermittlung einer Dispute-Lookup-Anfrage über Hazelcast.
     * Antwort wird innerhalb von 5 Sekunden erwartet.
     *
     * @param issuerId      Herausgeberkennung
     * @param cardReference Kartenreferenz
     * @return              JSON-Antwort des {@link DisputeLookupResponseDto} oder Fehler-/Timeout-Nachricht
     */
    @UiService(value = "publishDisputesLookupRequest", method = MethodType.GET, requiresAuthentication = false)
    public String publishDisputesLookupRequest(
            @ServiceParam("issuerId") String issuerId,
            @ServiceParam("cardReference") String cardReference) {

        try {
            String correlationId = UUID.randomUUID().toString();

            DisputeLookupRequestMetadataDto metadataDto = DisputeLookupRequestMetadataDto.newBuilder()
                    .setRequestChannel("APL-UI")
                    .setMessageType("DISPUTE_LOOKUP")
                    .setRequestedBy("UI-MANUAL-TEST")
                    .setBusinessContext("test")
                    .build();

            DisputeLookupRequestDto request = DisputeLookupRequestDto.newBuilder()
                    .setMetadata(metadataDto)
                    .setIssuerId(issuerId)
                    .setCardReference(cardReference)
                    .build();

            DisputeLookupRequestWrapperDto wrapper = DisputeLookupRequestWrapperDto.newBuilder()
                    .setCorrelationId(correlationId)
                    .setPayload(request)
                    .build();

            hazelcastInstance.getReliableTopic("DisputeLookupRequestReliableTopic")
                    .publish(wrapper.toByteArray());

            disputeLookupResponseTracker.register(correlationId);
            CompletableFuture<DisputeLookupResponseDto> future = disputeLookupResponseTracker.await(correlationId);

            DisputeLookupResponseDto response = future.get(5, TimeUnit.SECONDS);
            return ProtobufJsonUtil.printProtoToJson(response);

        } catch (TimeoutException te) {
            return "{ \"status\": \"timeout\", \"message\": \"No response in 5 seconds\" }";
        } catch (Exception e) {
            LOGGER.error("Failed to process publishDisputesLookupRequest", e);
            return "{ \"status\": \"error\", \"message\": \"" + e.getMessage() + "\" }";
        }
    }

    /**
     * UI-Service-Endpunkt zur asynchronen Detailabfrage eines Streitfallordners über Hazelcast.
     *
     * @param issuerId               Herausgeberkennung
     * @param disputeFolderReference Referenznummer des Streitfallordners
     * @param embed                  Einzubettende Zusatzdaten (z. B. "events,documents")
     * @return                       JSON-Antwort des {@link DisputeResponseDto} oder Timeout/Fehler
     */
    @UiService(value = "publishDisputeDetailRequest", method = MethodType.GET, requiresAuthentication = false)
    public String publishDisputeDetailRequest(
            @ServiceParam("issuerId") String issuerId,
            @ServiceParam("disputeFolderReference") String disputeFolderReference,
            @ServiceParam(value = "embed") String embed) {

        try {
            String correlationId = UUID.randomUUID().toString();

            DisputeDetailRequestMetadataDto.Builder metaBuilder = DisputeDetailRequestMetadataDto.newBuilder()
                    .setRequestChannel("APL-UI")
                    .setMessageType("DISPUTE_FOLDER_DETAIL")
                    .setRequestedBy("UI-MANUAL-TEST")
                    .setBusinessContext("test");

            if (embed != null && !embed.isBlank()) {
                for (String val : embed.split("\\s*,\\s*")) {
                    metaBuilder.addEmbed(val);
                }
            }

            DisputeDetailRequestDto request = DisputeDetailRequestDto.newBuilder()
                    .setMetadata(metaBuilder.build())
                    .setIssuerId(issuerId)
                    .setDisputeFolderReference(disputeFolderReference)
                    .build();

            DisputeDetailRequestWrapperDto wrapper = DisputeDetailRequestWrapperDto.newBuilder()
                    .setCorrelationId(correlationId)
                    .setPayload(request)
                    .build();

            hazelcastInstance.getReliableTopic("DisputeDetailRequestReliableTopic")
                    .publish(wrapper.toByteArray());

            disputeDetailResponseTracker.register(correlationId);
            CompletableFuture<DisputeResponseDto> future = disputeDetailResponseTracker.await(correlationId);

            DisputeResponseDto response = future.get(5, TimeUnit.SECONDS);
            return ProtobufJsonUtil.printProtoToJson(response);

        } catch (TimeoutException te) {
            return "{ \"status\": \"timeout\", \"message\": \"No response in 5 seconds\" }";
        } catch (Exception e) {
            LOGGER.error("Failed to process publishDisputeDetailRequest", e);
            return "{ \"status\": \"error\", \"message\": \"" + e.getMessage() + "\" }";
        }
    }

    /**
     * Initialisiert nach dem Start der Bean die Listener für eingehende Antworten auf Hazelcast-Themen.
     */
    @PostConstruct
    public void initResponseListeners() {
        HazelcastListenerUtils.registerGenericResponseListener(
                hazelcastInstance,
                "DisputeDetailResponseReliableTopic",
                DisputeDetailResponseWrapperDto.parser(),
                DisputeDetailResponseWrapperDto::getCorrelationId,
                DisputeDetailResponseWrapperDto::getResponse,
                disputeDetailResponseTracker::complete,
                LOGGER
        );

        HazelcastListenerUtils.registerGenericResponseListener(
                hazelcastInstance,
                "DisputeLookupResponseReliableTopic",
                DisputeLookupResponseWrapperDto.parser(),
                DisputeLookupResponseWrapperDto::getCorrelationId,
                DisputeLookupResponseWrapperDto::getResponse,
                disputeLookupResponseTracker::complete,
                LOGGER
        );
    }
}

                -------------


package osplus.pkptuna.util;

import osplus.apl.core.api.AplComponent;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Generischer Antwort-Tracker basierend auf Korrelations-IDs.
 * Ermöglicht asynchrone Zuordnung von Antworten zu Anfragen in verteilten Systemen.
 *
 * @param <T> Typ der erwarteten Antwort
 */
@AplComponent
public class GenericResponseTracker<T> {

    // Thread-sichere Map zur Speicherung aller laufenden Anfragen
    private final Map<String, CompletableFuture<?>> pending = new ConcurrentHashMap<>();

    /**
     * Registriert eine neue erwartete Antwort anhand ihrer Korrelations-ID.
     *
     * @param correlationId Die eindeutige ID, die zur späteren Zuordnung der Antwort verwendet wird
     * @param <T>           Der erwartete Typ der Antwort
     */
    public <T> void register(String correlationId) {
        pending.put(correlationId, new CompletableFuture<T>());
    }

    /**
     * Markiert eine Antwort als empfangen und löst das zugehörige Future aus.
     *
     * @param correlationId Die ID, mit der die Antwort zugeordnet wird
     * @param response      Die empfangene Antwort vom Typ T
     * @param <T>           Der Typ der Antwort
     */
    public <T> void complete(String correlationId, T response) {
        @SuppressWarnings("unchecked")
        CompletableFuture<T> future = (CompletableFuture<T>) pending.remove(correlationId);
        if (future != null) {
            future.complete(response);
        }
    }

    /**
     * Gibt das Future-Objekt zurück, das auf die Antwort wartet.
     *
     * @param correlationId Die zugehörige Korrelations-ID
     * @param <T>           Der erwartete Typ der Antwort
     * @return              CompletableFuture, das bei Antwort abgeschlossen wird
     */
    @SuppressWarnings("unchecked")
    public <T> CompletableFuture<T> await(String correlationId) {
        return (CompletableFuture<T>) pending.get(correlationId);
    }
}


-----------------


package osplus.pkptuna.util;

import com.google.protobuf.Message;
import com.google.protobuf.Parser;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.topic.ITopic;
import osplus.fi.core.logging.api.Logger;

import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * Hilfsklasse zur Registrierung generischer Hazelcast-Listener für Protobuf-Nachrichten.
 * Diese Listener lesen Nachrichten von einem Topic, parsen sie, und leiten die extrahierte Antwort
 * anhand der Korrelations-ID an einen Consumer weiter.
 */
public class HazelcastListenerUtils {

    /**
     * Registriert einen generischen Listener auf einem Hazelcast-Topic, der Protobuf-Nachrichten verarbeitet.
     *
     * @param hazelcastInstance      Die Hazelcast-Instanz
     * @param topicName              Der Name des Topics, das überwacht werden soll
     * @param parser                 Protobuf-Parser zur Umwandlung des Payloads
     * @param correlationIdExtractor Funktion zur Extraktion der Korrelations-ID aus dem Wrapper
     * @param responseExtractor      Funktion zur Extraktion der Antwort-Nutzlast aus dem Wrapper
     * @param responseConsumer       Callback zur Weitergabe der extrahierten Antwort
     * @param logger                 Logger-Instanz für Fehlerprotokollierung
     * @param <W>                    Typ des empfangenen Wrapper-Protobuf-Objekts
     * @param <R>                    Typ der extrahierten Antwort
     */
    public static <W extends Message, R> void registerGenericResponseListener(
            HazelcastInstance hazelcastInstance,
            String topicName,
            Parser<W> parser,
            Function<W, String> correlationIdExtractor,
            Function<W, R> responseExtractor,
            BiConsumer<String, R> responseConsumer,
            Logger logger) {

        // Zugriff auf das konfigurierte Topic
        ITopic<byte[]> topic = hazelcastInstance.getReliableTopic(topicName);

        // Registrierung eines Hazelcast-MessageListeners
        topic.addMessageListener(message -> {
            try {
                byte[] messageBytes = message.getMessageObject();
                W wrapper = parser.parseFrom(messageBytes);

                // Extraktion von Korrelations-ID und Antwort
                String correlationId = correlationIdExtractor.apply(wrapper);
                R response = responseExtractor.apply(wrapper);

                // Übergabe an den angegebenen Consumer
                responseConsumer.accept(correlationId, response);

            } catch (Exception e) {
                logger.error("Fehler beim Verarbeiten der Antwort von Topic '{}'", topicName, e);
            }
        });

        logger.info("Antwort-Listener auf Topic '{}' registriert.", topicName);
    }
}
