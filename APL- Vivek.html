package osplus.pkptuna.hazelcast.pubsub;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import osplus.apl.core.api.AplComponent;
import osplus.pkptuna.hazelcast.configprops.HazelcastFlowConfigs;
import osplus.pkptuna.hazelcast.pubsub.flow.FlowHandler;
import osplus.pkptuna.hazelcast.pubsub.flow.FlowHandlerRegistry;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@AplComponent
@EnableScheduling
public class GenericHazelcastConsumer {

    private static final Logger LOGGER = LoggerFactory.getLogger(GenericHazelcastConsumer.class);

    private final HazelcastInstance hazelcastInstance;
    private final HazelcastFlowConfigs flowConfigs;
    private final FlowHandlerRegistry flowHandlerRegistry;

    // Track round-robin position for each flow
    private final Map<String, Integer> partitionTracker = new ConcurrentHashMap<>();

    public GenericHazelcastConsumer(HazelcastInstance hazelcastInstance,
                                    HazelcastFlowConfigs flowConfigs,
                                    FlowHandlerRegistry flowHandlerRegistry) {
        this.hazelcastInstance = hazelcastInstance;
        this.flowConfigs = flowConfigs;
        this.flowHandlerRegistry = flowHandlerRegistry;
    }

    @PostConstruct
    public void init() {
        LOGGER.info("‚úÖ GenericHazelcastConsumer initialized for flows: {}", flowConfigs.getFlowMap().keySet());
    }

    @Scheduled(fixedRate = 1000)
    public void pollRequestMaps() {
        for (Map.Entry<String, HazelcastFlowConfigs.FlowConfig> entry : flowConfigs.getFlowMap().entrySet()) {
            String flowName = entry.getKey();
            HazelcastFlowConfigs.FlowConfig config = entry.getValue();
            FlowHandler<?, ?> handler = flowHandlerRegistry.getHandler(flowName);

            for (int i = 0; i < config.partitions(); i++) {
                String mapName = config.mapBase() + i;
                IMap<String, ?> requestMap = hazelcastInstance.getMap(mapName);

                for (Object rawKey : requestMap.keySet()) {
                    try {
                        String correlationId = rawKey.toString();
                        Object rawRequest = requestMap.get(correlationId);

                        if (rawRequest == null) {
                            continue;
                        }

                        LOGGER.info("üì• [{}] Processing entry with correlationId={}", flowName, correlationId);

                        Object response = handler.handleRequest(rawRequest);

                        Object wrappedResponse = handler.wrapResponse(correlationId, response);

                        handler.sendResponse(hazelcastInstance, config.responseTopic(), wrappedResponse);

                        requestMap.remove(correlationId);

                        LOGGER.info("‚úÖ [{}] Responded and removed entry with correlationId={}", flowName, correlationId);

                    } catch (Exception e) {
                        LOGGER.error("‚ùå [{}] Error processing map {}: {}", flowName, mapName, e.getMessage(), e);
                    }
                }
            }
        }
    }
}
