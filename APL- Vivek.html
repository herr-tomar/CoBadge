package osplus.pkptuna.util;

import java.util.Map;
import java.util.concurrent.*;

/**
 * Zentraler, generischer Tracker für mehrere Antworttypen basierend auf Korrelations-ID und Typ.
 */
public class CentralResponseTracker {

    private final Map<String, CompletableFuture<?>> pending = new ConcurrentHashMap<>();

    /**
     * Registriert eine erwartete Antwort mit Korrelations-ID.
     */
    public <T> void register(String correlationId) {
        pending.put(correlationId, new CompletableFuture<T>());
    }

    /**
     * Markiert eine Antwort als abgeschlossen.
     */
    public <T> void complete(String correlationId, T response) {
        @SuppressWarnings("unchecked")
        CompletableFuture<T> future = (CompletableFuture<T>) pending.remove(correlationId);
        if (future != null) {
            future.complete(response);
        }
    }

    /**
     * Gibt das Future-Objekt zurück, um auf die Antwort zu warten.
     */
    @SuppressWarnings("unchecked")
    public <T> CompletableFuture<T> await(String correlationId) {
        return (CompletableFuture<T>) pending.get(correlationId);
    }
}

---------

            import com.google.protobuf.Message;
import com.google.protobuf.Parser;

import java.util.function.BiConsumer;
import java.util.function.Function;

public class HazelcastListenerUtils {

    public static <W extends Message, R> void registerGenericResponseListener(
            HazelcastInstance hazelcastInstance,
            String topicName,
            Parser<W> parser,
            Function<W, String> correlationIdExtractor,
            Function<W, R> responseExtractor,
            BiConsumer<String, R> responseConsumer,
            Logger logger) {

        hazelcastInstance.getReliableTopic(topicName).addMessageListener(message -> {
            try {
                byte[] messageBytes = message.getMessageObject();
                W wrapper = parser.parseFrom(messageBytes);
                String correlationId = correlationIdExtractor.apply(wrapper);
                R response = responseExtractor.apply(wrapper);
                responseConsumer.accept(correlationId, response);
            } catch (Exception e) {
                logger.error("Fehler beim Verarbeiten der Antwort von Topic '{}'", topicName, e);
            }
        });

        logger.info("Antwort-Listener auf Topic '{}' registriert.", topicName);
    }
}


------------

@PostConstruct
public void initResponseListeners() {

    HazelcastListenerUtils.registerGenericResponseListener(
        hazelcastInstance,
        "DisputeDetailResponseReliableTopic",
        DisputeDetailResponseWrapperDto.parser(),
        DisputeDetailResponseWrapperDto::getCorrelationId,
        DisputeDetailResponseWrapperDto::getResponse,
        DisputeDetailResponseTracker::complete,
        LOGGER
    );

    HazelcastListenerUtils.registerGenericResponseListener(
        hazelcastInstance,
        "DisputeLookupResponseReliableTopic",
        DisputeLookupResponseWrapperDto.parser(),
        DisputeLookupResponseWrapperDto::getCorrelationId,
        DisputeLookupResponseWrapperDto::getResponse,
        DisputeLookupResponseTracker::complete,
        LOGGER
    );
}

